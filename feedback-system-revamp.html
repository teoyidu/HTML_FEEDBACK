<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Chatbot Feedback System</title>
  <style>
    /* General styles */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background-color: #111827;
      color: #f3f4f6;
      line-height: 1.5;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
    }

    h1 {
      font-size: 1.5rem;
      font-weight: bold;
      margin-bottom: 1.5rem;
    }

    /* Search bar */
    .search-container {
      position: relative;
      margin-bottom: 1.5rem;
    }

    .search-icon {
      position: absolute;
      left: 0.75rem;
      top: 50%;
      transform: translateY(-50%);
      color: #9ca3af;
    }

    .search-input {
      width: 100%;
      padding: 0.625rem 0.75rem 0.625rem 2.5rem;
      background-color: #1f2937;
      border: 1px solid #374151;
      border-radius: 0.5rem;
      color: #f3f4f6;
      font-size: 0.875rem;
    }

    .search-input:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 1px #3b82f6;
    }
    /* QDrant Panel Styles */
    .qdrant-panel {
      position: fixed;
      top: 70px;
      right: 20px;
      width: 300px;
      background-color: #1f2937;
      border-radius: 0.5rem;
      padding: 1rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 40;
      border: 1px solid #374151;
    }

    .qdrant-panel h3 {
      margin-top: 0;
      margin-bottom: 1rem;
      font-size: 1.1rem;
      color: #e5e7eb;
      border-bottom: 1px solid #374151;
      padding-bottom: 0.5rem;
    }

    .qdrant-input-group {
      margin-bottom: 1rem;
    }

    .qdrant-input-group label {
      display: block;
      margin-bottom: 0.25rem;
      color: #d1d5db;
      font-size: 0.875rem;
    }

    .qdrant-input-group textarea {
      width: 100%;
      min-height: 80px;
      padding: 0.5rem;
      background-color: #2d3748;
      color: #e5e7eb;
      border: 1px solid #4b5563;
      border-radius: 0.25rem;
      font-size: 0.875rem;
      resize: vertical;
    }

    .qdrant-input-group textarea:focus {
      border-color: #2563eb;
      outline: none;
      box-shadow: 0 0 0 1px #2563eb;
    }

    .qdrant-send-btn {
      width: 100%;
      padding: 0.5rem;
      background-color: #2563eb;
      color: white;
      border: none;
      border-radius: 0.25rem;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .qdrant-send-btn:hover {
      background-color: #1d4ed8;
    }

    .highlighted {
      animation: highlight-pulse 2s ease;
    }

    @keyframes highlight-pulse {
      0%, 100% { border-color: #4b5563; }
      50% { border-color: #2563eb; box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.3); }
    }

    /* QDrant Confirmation Dialog */
    .qdrant-confirm-dialog {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .qdrant-confirm-content {
      background-color: #1f2937;
      border-radius: 0.5rem;
      padding: 1.5rem;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }

    .qdrant-confirm-title {
      font-size: 1.1rem;
      margin-top: 0;
      margin-bottom: 1rem;
      font-weight: 500;
    }

    .qdrant-confirm-text {
      margin-bottom: 1.5rem;
      color: #d1d5db;
    }

    .qdrant-confirm-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
    }

    .qdrant-confirm-btn {
      padding: 0.5rem 1rem;
      border-radius: 0.25rem;
      font-size: 0.875rem;
      cursor: pointer;
    }

    .qdrant-confirm-btn.cancel {
      background-color: #4b5563;
      color: #e5e7eb;
      border: none;
    }

    .qdrant-confirm-btn.confirm {
      background-color: #2563eb;
      color: white;
      border: none;
    }

    /* Filter styles */
    .filter-section {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }

    .filter-label {
      display: flex;
      align-items: center;
      margin-right: 0.5rem;
    }

    .filter-label svg {
      margin-right: 0.25rem;
    }

    .filter-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .filter-btn {
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.875rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: none;
      cursor: pointer;
      transition: background-color 0.2s;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .filter-btn:hover {
      background-color: #374151;
    }

    .filter-btn.active {
      background-color: #2563eb;
      color: white;
    }

    /* Feedback filters */
    .feedback-filters {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      border-top: 1px solid #374151;
      padding-top: 1rem;
    }

    /* Page size buttons */
    .page-size {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      align-items: center;
    }

    .page-size-btn {
      padding: 0.25rem 0.75rem;
      border-radius: 0.25rem;
      font-size: 0.875rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: none;
      cursor: pointer;
    }

    .page-size-btn.active {
      background-color: #374151;
      color: white;
    }

    /* Results count */
    .results-count {
      margin-bottom: 1rem;
      color: #9ca3af;
      font-size: 0.875rem;
    }

    /* Content with formatting support */
    .conversation-content, .cypher-query, .suggestion-list li {
      white-space: pre-wrap;
      word-wrap: break-word;
      line-height: 1.5;
    }

    /* Sort controls */
    .sort-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }

    .sort-btn {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.25rem 0.75rem;
      border-radius: 0.25rem;
      font-size: 0.875rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: none;
      cursor: pointer;
    }

    .sort-btn:hover {
      background-color: #374151;
    }

    .sort-btn.active {
      background-color: #2563eb;
      color: white;
    }
    /* Date range filter */
    .date-range-filter {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
    }

    .date-inputs {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .date-input-group {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .date-input {
      padding: 0.35rem 0.5rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: 1px solid #374151;
      border-radius: 0.25rem;
      font-size: 0.875rem;
    }

    .date-input:focus {
      border-color: #3b82f6;
      outline: none;
    }

    /* Cypher query styling */
    .cypher-query {
      background-color: #2d3748;
      padding: 0.75rem;
      border-radius: 0.25rem;
      margin-bottom: 1rem;
      font-family: monospace;
      font-size: 0.9rem;
      overflow-x: auto;
    }

    /* Enhance the suggestion list */
    .suggestion-list li {
      padding: 0.75rem;
      background-color: #374151;
      border-radius: 0.5rem;
      margin-bottom: 0.75rem;
    }
    /* Additional data buttons styles */
    .additional-data-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .data-btn {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.4rem 0.6rem;
      background-color: #2d3748;
      color: #d1d5db;
      border: none;
      border-radius: 0.375rem;
      font-size: 0.75rem;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.2s;
    }

    .data-btn:hover:not(:disabled) {
      background-color: #4a5568;
      transform: translateY(-1px);
    }

    .data-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .data-btn svg {
      width: 14px;
      height: 14px;
    }

    /* Data popup styles */
    .data-popup {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.75);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    .data-popup.active {
      opacity: 1;
      visibility: visible;
    }

    .popup-content {
      background-color: #1f2937;
      border-radius: 0.5rem;
      width: 90%;
      max-width: 900px;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
      transform: scale(0.9);
      transition: transform 0.3s ease;
    }

    .data-popup.active .popup-content {
      transform: scale(1);
    }

    .popup-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      border-bottom: 1px solid #374151;
    }

    .popup-header h3 {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 500;
    }

    .popup-close {
      background: none;
      border: none;
      color: #9ca3af;
      cursor: pointer;
      padding: 0.25rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 0.25rem;
      transition: background-color 0.2s;
    }

    .popup-close:hover {
      background-color: #374151;
    }

    .popup-body {
      padding: 1rem;
      overflow-y: auto;
      flex: 1;
    }

    .popup-body pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: monospace;
      font-size: 0.9rem;
      line-height: 1.5;
      color: #d1d5db;
      margin: 0;
      padding: 0.5rem;
      background-color: #2d3748;
      border-radius: 0.25rem;
      overflow-x: auto;
    }

    /* MongoDB Connection Styles */
    .connection-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
      font-size: 0.875rem;
    }

    .connection-status .status-indicator {
      width: 0.75rem;
      height: 0.75rem;
      border-radius: 50%;
      background-color: #9ca3af;
    }

    .connection-status .status-indicator.connected {
      background-color: #10b981;
    }

    .connection-status .status-indicator.disconnected {
      background-color: #ef4444;
    }

    /* Feedback items */
    .feedback-items {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .feedback-item {
      position: relative;
      display: flex;
      border-radius: 0.5rem;
      background-color: #1f2937;
      overflow: hidden;
      animation: fadeIn 0.3s ease-out;
      transition: all 0.3s ease;
    }

    /* Schema buttons on the left */
    .schema-buttons {
      display: flex;
      flex-direction: column;
      padding: 1rem;
      background-color: #1f2937;
      border-right: 1px solid #374151;
      min-width: 120px;
      justify-content: center;
      align-items: center;
      gap: 0.5rem;
    }

    .schema-btn {
      display: block;
      width: 100%;
      padding: 0.5rem;
      border-radius: 0.5rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: 1px solid #374151;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
    }

    .schema-btn:hover {
      background-color: #2d3748;
    }

    .schema-btn.active {
      background-color: #2563eb;
      color: white;
      border-color: #2563eb;
    }

    /* Content buttons in the middle */
    .feedback-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      padding: 1rem;
    }

    /* User info at top */
    .feedback-user-info {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: #9ca3af;
      border-bottom: 1px solid #374151;
      padding-bottom: 0.5rem;
    }

    .user-name {
      font-weight: 500;
    }

    .datetime {
      font-style: italic;
    }

    /* Conversation and action buttons */
    .feedback-buttons {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .conversation-btn {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      background-color: #374151;
      border: none;
      border-radius: 0.5rem;
      color: white;
      font-size: 1rem;
      text-align: left;
      cursor: pointer;
      transition: background-color 0.2s;
      min-height: 60px;
    }

    .conversation-btn:hover {
      background-color: #4b5563;
    }

    .small-buttons {
      display: flex;
      gap: 0.5rem;
      width: 100%;
    }

    .suggestion-btn, .cypher-btn {
      flex: 1;
      padding: 0.5rem;
      background-color: #374151;
      border: none;
      border-radius: 0.5rem;
      color: white;
      font-size: 0.875rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .suggestion-btn:hover, .cypher-btn:hover {
      background-color: #4b5563;
    }

    /* Feedback actions on the right */
    .feedback-actions {
      display: flex;
      flex-direction: column;
      padding: 1rem;
      background-color: #1f2937;
      border-left: 1px solid #374151;
      justify-content: center;
      gap: 1rem;
    }

    .action-btn {
      padding: 0.5rem;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
    }

    .action-btn:hover {
      transform: scale(1.1);
    }

    .action-btn svg {
      width: 20px;
      height: 20px;
    }

    .action-btn.positive {
      background-color: #10b981; /* Green */
      color: white;
    }

    .action-btn.positive:hover {
      background-color: #059669; /* Brighter green */
    }

    .action-btn.archive {
      background-color: #f59e0b; /* Yellow */
      color: white;
    }

    .action-btn.archive:hover {
      background-color: #d97706; /* Brighter yellow */
    }

    .action-btn.negative {
      background-color: #ef4444; /* Red */
      color: white;
    }

    .action-btn.negative:hover {
      background-color: #dc2626; /* Brighter red */
    }

    /* Modal styles for content popup */
    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    .modal-backdrop.active {
      opacity: 1;
      visibility: visible;
    }

    .modal-content {
      background-color: #1f2937;
      border-radius: 0.5rem;
      width: 90%;
      max-width: 900px;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      transform: scale(0.9);
      transition: transform 0.3s ease;
    }

    .modal-backdrop.active .modal-content {
      transform: scale(1);
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem;
      border-bottom: 1px solid #374151;
    }

    .modal-title {
      font-size: 1.2rem;
      font-weight: 500;
    }

    .modal-close {
      background: none;
      border: none;
      color: #9ca3af;
      cursor: pointer;
      padding: 0.5rem;
    }

    .modal-body {
      flex: 1;
      padding: 1rem;
      overflow-y: auto;
    }

    /* User info in modal */
    .user-info {
      display: flex;
      justify-content: space-between;
      padding: 0.5rem 0;
      font-size: 0.875rem;
      color: #9ca3af;
      margin-bottom: 0.5rem;
    }

    /* Conversation Tab */
    .conversation-item {
      margin-bottom: 1rem;
    }

    .conversation-item.user {
      text-align: right;
    }

    .conversation-item.assistant {
      text-align: left;
    }

    .conversation-bubble {
      display: inline-block;
      max-width: 80%;
      padding: 0.75rem;
      border-radius: 0.5rem;
      white-space: pre-line;
    }

    .conversation-item.user .conversation-bubble {
      background-color: #2563eb;
      color: white;
      border-top-right-radius: 0;
    }

    .conversation-item.assistant .conversation-bubble {
      background-color: #374151;
      color: white;
      border-top-left-radius: 0;
    }

    .conversation-role {
      font-size: 0.875rem;
      font-weight: 500;
      margin-bottom: 0.25rem;
      opacity: 0.7;
    }

    /* Suggestion and Cypher Query Tabs */
    .suggestion-list, .cypher-list {
      list-style-type: none;
      padding-left: 0;
    }

    .suggestion-list li, .cypher-list li {
      padding: 0.75rem;
      background-color: #374151;
      border-radius: 0.5rem;
      margin-bottom: 0.75rem;
      word-wrap: break-word;
      white-space: pre-wrap;
    }

    /* Tabs Navigation */
    .tabs-container {
      margin-bottom: 1rem;
    }

    .tabs-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .tabs-list {
      display: flex;
      gap: 0.25rem;
      overflow-x: auto;
      scrollbar-width: thin;
      padding: 0.25rem 0;
      flex-grow: 1;
    }

    .tab-nav-btn {
      padding: 0.5rem 0.75rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: none;
      border-radius: 0.25rem;
      cursor: pointer;
      white-space: nowrap;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .tab-nav-btn:hover {
      background-color: #374151;
    }

    .tab-nav-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .pagination-btn {
      padding: 0.5rem 0.75rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: none;
      border-radius: 0.25rem;
      cursor: pointer;
    }

    .pagination-btn.active {
      background-color: #2563eb;
      color: white;
    }

    /* No results */
    .no-results {
      text-align: center;
      padding: 2.5rem 0;
      color: #9ca3af;
    }
    /* Hide user info in modal */
    #modal-user-info {
      display: none;
    } 

    /* Animations and keyframes */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .hidden {
      display: none;
    }

    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      color: #9ca3af;
    }

    .loading::before {
      content: "";
      width: 20px;
      height: 20px;
      margin-right: 10px;
      border-radius: 50%;
      border: 2px solid #9ca3af;
      border-top-color: #3b82f6;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Mürşit Feedback Sistemi</h1>
  <!-- QDrant Panel -->
  <div id="qdrant-panel" class="qdrant-panel">
    <h3>Add to QDrant</h3>
    <div class="qdrant-input-group">
      <label for="qdrant-question">Question:</label>
      <textarea id="qdrant-question" placeholder="Enter question text..."></textarea>
    </div>
    <div class="qdrant-input-group">
      <label for="qdrant-cypher">Cypher Query:</label>
      <textarea id="qdrant-cypher" placeholder="Enter cypher query..."></textarea>
    </div>
    <button id="send-to-qdrant" class="qdrant-send-btn">Send to QDrant</button>
  </div>

  <!-- MongoDB Connection Status -->
  <div class="connection-status">
    <div id="connection-indicator" class="status-indicator"></div>
    <span id="connection-text">Connecting to MongoDB...</span>
  </div>

  <!-- Search Bar -->
  <div class="search-container">
    <svg class="search-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="11" cy="11" r="8"></circle>
      <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
    </svg>
    <input type="text" id="search-input" class="search-input" placeholder="Search questions or queries...">
  </div>

  <!-- Schema Filter Buttons -->
  <div class="filter-section">
    <div class="filter-label">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
      </svg>
      <span>Şema Filtreleri:</span>
    </div>
    <div id="schema-filters" class="filter-buttons">
      <button data-schema="Mesai" class="filter-btn">Mesai</button>
      <button data-schema="Mukavele" class="filter-btn">Mukavele</button>
      <button data-schema="Genel" class="filter-btn">Genel</button>
    </div>
  </div>

  <!-- Feedback Filter Buttons -->
  <div class="feedback-filters">
    <div class="filter-label">
      <span>Feedback Filtreleri:</span>
    </div>
    <button id="positive-filter" class="filter-btn">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
        <path d="M7 10v12"></path>
        <path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z"></path>
      </svg>
      Positive
    </button>
    <button id="negative-filter" class="filter-btn">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
        <path d="M17 14V2"></path>
        <path d="M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22h0a3.13 3.13 0 0 1-3-3.88Z"></path>
      </svg>
      Negative
    </button>
    <button id="hidden-filter" class="filter-btn">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
        <rect width="20" height="5" x="2" y="3" rx="1"></rect>
        <path d="M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8"></path>
        <path d="M10 12h4"></path>
      </svg>
      Show Archived
    </button>
  </div>

  <!-- Page Size Selection -->
  <div class="page-size">
    <span>Gösterilecek:</span>
    <button data-size="20" class="page-size-btn active">20</button>
    <button data-size="40" class="page-size-btn">40</button>
    <button data-size="100" class="page-size-btn">100</button>
    <button data-size="200" class="page-size-btn">200</button>
  </div>

  <!-- Date Sorting Controls -->
  <div class="sort-controls">
    <span>Sort by date:</span>
    <button id="sort-newest" class="sort-btn active">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="m3 16 4 4 4-4"/>
        <path d="M7 20V4"/>
        <path d="M11 4h10"/>
        <path d="M11 8h7"/>
        <path d="M11 12h4"/>
      </svg>
      Newest First
    </button>
    <button id="sort-oldest" class="sort-btn">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="m3 8 4-4 4 4"/>
        <path d="M7 4v16"/>
        <path d="M11 12h4"/>
        <path d="M11 16h7"/>
        <path d="M11 20h10"/>
      </svg>
      Oldest First
    </button>
  </div>
  <!-- Date Range Filter -->
  <div class="date-range-filter">
    <span>Filter by time:</span>
    <div class="date-inputs">
      <div class="date-input-group">
        <label for="date-from">From:</label>
        <input type="date" id="date-from" class="date-input">
      </div>
      <div class="date-input-group">
        <label for="date-to">To:</label>
        <input type="date" id="date-to" class="date-input">
      </div>
    </div>
    <button id="apply-date-filter" class="filter-btn">Apply</button>
    <button id="clear-date-filter" class="filter-btn">Clear</button>
  </div>

  <!-- Tabs Navigation -->
  <div id="tabs-container" class="tabs-container">
    <div class="tabs-header">
      <button id="prev-tab-btn" class="tab-nav-btn">&laquo; Previous</button>
      <div id="tabs-list" class="tabs-list"></div>
      <button id="next-tab-btn" class="tab-nav-btn">Next &raquo;</button>
    </div>
  </div>

  <!-- Results count -->
  <div id="results-count" class="results-count"></div>

  <!-- Feedback Items -->
  <div id="feedback-items" class="feedback-items"></div>

  <!-- No results message -->
  <div id="no-results" class="no-results hidden">
    No questions found matching your criteria
  </div>
</div>

<!-- Modal for viewing feedback content -->
<div id="feedback-modal" class="modal-backdrop">
  <div class="modal-content">
    <div class="modal-header">
      <div class="modal-title" id="modal-title">Feedback Details</div>
      <button class="modal-close" id="modal-close">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
    </div>
    <div class="user-info" id="modal-user-info">
      <span id="modal-username">User: username</span>
      <span id="modal-datetime">Date: YYYY-MM-DD HH:MM</span>
    </div>
    <div class="modal-body" id="modal-body">
      <!-- Content will be dynamically inserted here -->
    </div>
  </div>
</div>

<script>
  // MongoDB API config
  const API_BASE_URL = "http://localhost:3000/api"; // Change this to your deployed API URL in production

  // App state
  let data = [];
  let filteredData = [];
  let activeSchema = null;
  let activeFeedbackFilter = null;
  let showHidden = false;
  let pageSize = 20;
  let searchQuery = '';
  let currentItemId = null;
  let schemaList = ["Mesai", "Mukavele", "Genel"];
  let currentPage = 0;
  let totalPages = 0;
  let visibleTabCount = 5; // Number of tabs to show at once
  let sortOrder = 'newest'; // 'newest' or 'oldest'
  let dateFrom = null;
  let dateTo = null;

  // Add these global variables near the top of your script (around line 400)
  // This ensures that any code trying to access these variables won't cause reference errors

  // Default value for activeTypeFilter
  window.activeTypeFilter = null;

  // Dummy function for filterByType
  window.filterByType = function(type) {
    console.log('Type filtering is disabled, ignoring request to filter by:', type);
    return false;
  };

  // Dummy function for initializeTypeFilters
  window.initializeTypeFilters = function() {
    console.log('Type filters initialization skipped (feature disabled)');
    return false;
  };

  // Remove the type filters section from DOM
  document.addEventListener('DOMContentLoaded', function() {
    // Find and remove type filters container if it exists
    const typeFiltersSection = document.querySelector('.filter-section:has(#type-filters)');
    if (typeFiltersSection) {
      console.log('Removing type filters section from DOM');
      typeFiltersSection.remove();
    }

    // Or just the inner element
    const typeFilters = document.getElementById('type-filters');
    if (typeFilters) {
      console.log('Removing type filters element from DOM');
      typeFilters.remove();
    }
  });

  // Modify applyFilters to skip type filtering
  // This is a patch to be applied to the original function
  const originalApplyFilters = window.applyFilters;
  if (typeof originalApplyFilters === 'function') {
    window.applyFilters = function() {
      // Access safe variables
      window.activeTypeFilter = window.activeTypeFilter || null;

      // Call original with wrapped try/catch
      try {
        return originalApplyFilters.apply(this, arguments);
      } catch (error) {
        console.error('Error in applyFilters:', error);

        // Fallback implementation
        let filtered = [...data];

        // Apply schema filter if active
        if (activeSchema) {
          filtered = filtered.filter(item => item.schema === activeSchema);
        }

        // Apply feedback filter if active
        if (activeFeedbackFilter) {
          filtered = filtered.filter(item => item.feedback === activeFeedbackFilter);
        }

        // Apply hidden filter
        if (!showHidden) {
          filtered = filtered.filter(item => !item.hidden);
        }

        // Apply search query
        if (searchQuery) {
          filtered = filtered.filter(item =>
                  (item.question && item.question.toLowerCase().includes(searchQuery)) ||
                  (item.user && item.user.toLowerCase().includes(searchQuery))
          );
        }

        filteredData = filtered;
        renderItems();
      }
    };
  }

  // Remove type filters references from fix scripts
  function patchExternalScripts() {
    // Create a MutationObserver to watch for script additions
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList') {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeName === 'SCRIPT' && node.src) {
              // For pagination-fix.js
              if (node.src.includes('pagination-fix.js')) {
                console.log('Patching pagination-fix.js...');
                setTimeout(() => {
                  // Safe access to window.applyFilters
                  const originalApplyFilters = window.applyFilters;
                  if (typeof originalApplyFilters === 'function') {
                    window.applyFilters = function() {
                      try {
                        // Ensure activeTypeFilter exists
                        window.activeTypeFilter = window.activeTypeFilter || null;
                        return originalApplyFilters.apply(this, arguments);
                      } catch (error) {
                        console.error('Error in patched applyFilters:', error);
                      }
                    };
                  }
                }, 200);
              }
            }
          });
        }
      });
    });

    // Start observing
    observer.observe(document.documentElement, { childList: true, subtree: true });

    // Return the observer to stop it later if needed
    return observer;
  }

  // Call the patching function after a delay
  setTimeout(patchExternalScripts, 100);

  function getElement(id, create = false) {
    let element = document.getElementById(id);

    if (!element && create) {
      console.log(`Creating missing element with ID: ${id}`);
      element = document.createElement('div');
      element.id = id;

      // Style and append depending on the element type
      switch(id) {
        case 'connection-indicator':
          element.className = 'status-indicator';
          const connectionStatus = document.querySelector('.connection-status');
          if (connectionStatus) {
            connectionStatus.appendChild(element);
          } else {
            // Create connection status container if needed
            const container = document.createElement('div');
            container.className = 'connection-status';
            container.appendChild(element);

            // Add connection text element
            const connectionText = document.createElement('span');
            connectionText.id = 'connection-text';
            connectionText.textContent = 'Connecting to MongoDB...';
            container.appendChild(connectionText);

            // Insert at the top of the container
            const mainContainer = document.querySelector('.container');
            if (mainContainer && mainContainer.firstChild) {
              mainContainer.insertBefore(container, mainContainer.firstChild.nextSibling);
            } else {
              document.body.appendChild(container);
            }
          }
          break;

        case 'connection-text':
          element.textContent = 'Connecting to MongoDB...';
          const statusIndicator = document.querySelector('.connection-status');
          if (statusIndicator) {
            statusIndicator.appendChild(element);
          } else {
            document.body.appendChild(element);
          }
          break;

        case 'type-filters':
          element.className = 'filter-section';
          element.innerHTML = `
          <div class="filter-label">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
            </svg>
            <span>Type Filters:</span>
          </div>
          <div class="filter-buttons">
            <!-- Type filter buttons will be added dynamically -->
          </div>
        `;

          // Insert after schema filters
          const schemaFilters = document.getElementById('schema-filters');
          if (schemaFilters) {
            const parentNode = schemaFilters.parentNode;
            if (parentNode) {
              parentNode.insertBefore(element, schemaFilters.nextSibling);
            }
          } else {
            document.body.appendChild(element);
          }
          break;

        case 'dialog-content':
          element.className = 'modal-body';

          // Find modal or create one
          const modal = document.getElementById('feedback-modal');
          if (modal) {
            const modalContent = modal.querySelector('.modal-content');
            if (modalContent) {
              modalContent.appendChild(element);
            } else {
              modal.appendChild(element);
            }
          } else {
            document.body.appendChild(element);
          }
          break;

        case 'tabs-list':
          element.className = 'tabs-list';

          // Find tabs container
          const tabsContainer = document.getElementById('tabs-container');
          if (tabsContainer) {
            const tabsHeader = tabsContainer.querySelector('.tabs-header');
            if (tabsHeader) {
              // Find the proper position to insert
              const prevBtn = document.getElementById('prev-tab-btn');
              if (prevBtn && prevBtn.nextSibling) {
                tabsHeader.insertBefore(element, prevBtn.nextSibling);
              } else {
                tabsHeader.appendChild(element);
              }
            } else {
              tabsContainer.appendChild(element);
            }
          } else {
            document.body.appendChild(element);
          }
          break;

        default:
          // Default case, just append to body
          document.body.appendChild(element);
      }
    }

    return element || {
      // Return a dummy element if still not found and not created
      classList: { add: () => {}, remove: () => {}, toggle: () => {}, contains: () => false },
      textContent: '',
      innerHTML: '',
      appendChild: () => {},
      style: {}
    };
  }

  // Function to format date in a user-friendly way
  function formatDateTime(dateStr) {
    if (/\d{1,2}\/\d{1,2}\/\d{4}, \d{1,2}:\d{2}:\d{2}/.test(dateStr)) {
      return dateStr;
    }

    let date;

    if (typeof dateStr === 'string') {
      if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(dateStr)) {
        date = new Date(dateStr);
      } else if (/^\d{10}$/.test(dateStr)) {
        date = new Date(parseInt(dateStr) * 1000);
      } else if (/^\d{13}$/.test(dateStr)) {
        date = new Date(parseInt(dateStr));
      } else {
        date = new Date(dateStr);
      }
    } else if (dateStr instanceof Date) {
      date = dateStr;
    } else {
      return "Invalid date";
    }

    if (isNaN(date.getTime())) {
      return "Invalid date";
    }

    const options = {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    };

    return date.toLocaleDateString(undefined, options);
  }

  // Helper function to render formatted content with better HTML handling
  function renderFormattedContent(text) {
    if (!text) return '';

    if (text.includes('<') && text.includes('>')) {
      return text;
    }

    let formattedText = text.replace(/\n/g, '<br>');

    formattedText = formattedText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    formattedText = formattedText.replace(/__(.*?)__/g, '<strong>$1</strong>');

    if (formattedText.includes('|')) {
      const lines = formattedText.split('<br>');
      let inTable = false;
      let tableContent = '';
      let processedLines = [];

      for (let line of lines) {
        if (line.trim().startsWith('|') && line.trim().endsWith('|')) {
          if (!inTable) {
            inTable = true;
            tableContent = '<table class="conversation-table">';
          }

          const cells = line.split('|').filter(cell => cell.trim() !== '');
          tableContent += '<tr>';
          cells.forEach(cell => {
            tableContent += `<td>${cell.trim()}</td>`;
          });
          tableContent += '</tr>';
        } else {
          if (inTable) {
            tableContent += '</table>';
            processedLines.push(tableContent);
            inTable = false;
            tableContent = '';
          }
          processedLines.push(line);
        }
      }

      if (inTable) {
        tableContent += '</table>';
        processedLines.push(tableContent);
      }

      formattedText = processedLines.join('<br>');
    }

    return formattedText;
  }

  // Update the conversation modal function
  function openConversationModal(item) {
    currentItemId = item.id;

    document.getElementById('modal-title').textContent = "Conversation";
    document.getElementById('modal-username').textContent = `User: ${item.user}`;
    document.getElementById('modal-datetime').textContent = `Date: ${formatDateTime(item.datetime)}`;

    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = '';

    if (item.conversation && item.conversation.length > 0) {
      item.conversation.forEach(message => {
        const messageElement = document.createElement('div');
        messageElement.className = `conversation-item ${message.role}`;

        const formattedMessage = renderFormattedContent(message.message);

        messageElement.innerHTML = `
        <div class="conversation-bubble">
          <p class="conversation-role">${message.role === 'user' ? 'User' : 'Assistant'}</p>
          <div class="conversation-content">${formattedMessage}</div>
        </div>
      `;
        modalBody.appendChild(messageElement);
      });
    } else {
      modalBody.innerHTML = '<p>No conversation available</p>';
    }

    const modal = document.getElementById('feedback-modal');
    modal.classList.add('active');
  }

  // Update the suggestion modal function
  function openSuggestionModal(item) {
    currentItemId = item.id;

    document.getElementById('modal-title').textContent = "Suggestions";
    document.getElementById('modal-username').textContent = `User: ${item.user}`;
    document.getElementById('modal-datetime').textContent = `Date: ${formatDateTime(item.datetime)}`;

    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = '';

    const suggestionList = document.createElement('ul');
    suggestionList.className = 'suggestion-list';

    if (item.suggestions && item.suggestions.length > 0) {
      item.suggestions.forEach(suggestion => {
        const li = document.createElement('li');
        li.innerHTML = renderFormattedContent(suggestion);
        suggestionList.appendChild(li);
      });
    } else {
      const li = document.createElement('li');
      li.textContent = 'No suggestions available';
      suggestionList.appendChild(li);
    }

    modalBody.appendChild(suggestionList);

    const modal = document.getElementById('feedback-modal');
    modal.classList.add('active');
  }

  // Update the cypher query modal function
  function openCypherModal(item) {
    currentItemId = item.id;

    document.getElementById('modal-title').textContent = "Cypher Query";
    document.getElementById('modal-username').textContent = `User: ${item.user}`;
    document.getElementById('modal-datetime').textContent = `Date: ${formatDateTime(item.datetime)}`;

    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = '';

    const cypherContainer = document.createElement('div');
    cypherContainer.className = 'cypher-container';

    if (item.cypherQueries && item.cypherQueries.length > 0) {
      item.cypherQueries.forEach(query => {
        const queryElement = document.createElement('div');
        queryElement.className = 'cypher-query';
        queryElement.innerHTML = renderFormattedContent(query);
        cypherContainer.appendChild(queryElement);
      });
    } else {
      const noQueryElement = document.createElement('div');
      noQueryElement.textContent = 'No Cypher queries available';
      cypherContainer.appendChild(noQueryElement);
    }

    modalBody.appendChild(cypherContainer);

    const modal = document.getElementById('feedback-modal');
    modal.classList.add('active');
  }

  // Load or initialize DOM elements
  document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM fully loaded, initializing application...');

    // Create critical elements first
    getElement('connection-indicator', true);
    getElement('connection-text', true);
    getElement('type-filters', true);
    getElement('dialog-content', true);
    getElement('tabs-list', true);

    // Create schema buttons if they don't exist
    const schemaFilters = getElement('schema-filters', true);
    if (!schemaFilters.querySelector('.filter-btn')) {
      console.log('No schema buttons found, creating them...');
      schemaList.forEach(schema => {
        const button = document.createElement('button');
        button.className = 'filter-btn';
        button.dataset.schema = schema;
        button.textContent = schema;
        button.addEventListener('click', () => filterBySchema(schema));
        schemaFilters.appendChild(button);
      });
    }

    // Initialize other UI elements
    const searchInput = getElement('search-input');
    const schemaFilterButtons = document.querySelectorAll('#schema-filters .filter-btn');
    const positiveFilter = getElement('positive-filter');
    const negativeFilter = getElement('negative-filter');
    const hiddenFilter = getElement('hidden-filter');
    const pageSizeButtons = document.querySelectorAll('.page-size-btn');
    const resultsCount = getElement('results-count', true);
    const feedbackItems = getElement('feedback-items', true);
    const noResults = getElement('no-results', true);

    // Setup event listeners
    searchInput.addEventListener('input', () => {
      searchQuery = searchInput.value.toLowerCase();
      applyFilters();
    });

    // Setup schema buttons (already done above)

    // Feedback filter event listeners
    if (positiveFilter) {
      positiveFilter.addEventListener('click', () => {
        if (activeFeedbackFilter === 'positive') {
          activeFeedbackFilter = null;
          positiveFilter.classList.remove('active');
        } else {
          activeFeedbackFilter = 'positive';
          positiveFilter.classList.add('active');
          negativeFilter.classList.remove('active');
        }
        applyFilters();
      });
    }

    if (negativeFilter) {
      negativeFilter.addEventListener('click', () => {
        if (activeFeedbackFilter === 'negative') {
          activeFeedbackFilter = null;
          negativeFilter.classList.remove('active');
        } else {
          activeFeedbackFilter = 'negative';
          negativeFilter.classList.add('active');
          positiveFilter.classList.remove('active');
        }
        applyFilters();
      });
    }

    // Toggle hidden items
    if (hiddenFilter) {
      hiddenFilter.addEventListener('click', () => {
        showHidden = !showHidden;
        hiddenFilter.classList.toggle('active', showHidden);

        if (showHidden) {
          hiddenFilter.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
            <rect width="20" height="5" x="2" y="3" rx="1"></rect>
            <path d="M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8"></path>
            <path d="M10 12h4"></path>
          </svg>
          Hide Archived
        `;
        } else {
          hiddenFilter.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
            <rect width="20" height="5" x="2" y="3" rx="1"></rect>
            <path d="M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8"></path>
            <path d="M10 12h4"></path>
          </svg>
          Show Archived
        `;
        }
        applyFilters();
      });
    }

    // Page size buttons
    pageSizeButtons.forEach(button => {
      button.addEventListener('click', () => {
        pageSizeButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        pageSize = parseInt(button.dataset.size);
        renderItems();
      });
    });

    // Modal close button
    const modal = getElement('feedback-modal');
    const modalClose = getElement('modal-close');

    if (modalClose) {
      modalClose.addEventListener('click', () => {
        closeModal();
      });
    }

    // Close modal when clicking outside
    if (modal) {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          closeModal();
        }
      });
    }

    // Initialize with MongoDB connection after a short delay
    setTimeout(() => {
      console.log('Initializing MongoDB connection...');
      try {
        connectToMongoDB();
      } catch (error) {
        console.error('Error during initial MongoDB connection:', error);
        // Show error on the page
        const connectionText = getElement('connection-text', true);
        connectionText.textContent = 'Error connecting to MongoDB: ' + error.message;
      }
    }, 100);
  });

  function openConversationModal(item) {
    currentItemId = item.id;

    document.getElementById('modal-title').textContent = "Conversation";
    document.getElementById('modal-username').textContent = `User: ${item.user}`;
    document.getElementById('modal-datetime').textContent = `Date: ${formatDateTime(item.datetime)}`;

    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = '';

    if (item.conversation && item.conversation.length > 0) {
      item.conversation.forEach(message => {
        const messageElement = document.createElement('div');
        messageElement.className = `conversation-item ${message.role}`;

        const formattedMessage = renderFormattedContent(message.message);

        messageElement.innerHTML = `
        <div class="conversation-bubble">
          <p class="conversation-role">${message.role === 'user' ? 'User' : 'Assistant'}</p>
          <div class="conversation-content">${formattedMessage}</div>
        </div>
      `;
        modalBody.appendChild(messageElement);
      });
    } else {
      modalBody.innerHTML = '<p>No conversation available</p>';
    }

    const modal = document.getElementById('feedback-modal');
    modal.classList.add('active');
  }

  function openSuggestionModal(item) {
    currentItemId = item.id;

    document.getElementById('modal-title').textContent = "Suggestion";
    document.getElementById('modal-username').textContent = `User: ${item.user}`;
    document.getElementById('modal-datetime').textContent = `Date: ${formatDateTime(item.datetime)}`;

    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = '';

    const suggestionList = document.createElement('ul');
    suggestionList.className = 'suggestion-list';

    if (item.suggestions && item.suggestions.length > 0) {
      item.suggestions.forEach(suggestion => {
        const li = document.createElement('li');
        li.textContent = suggestion;
        suggestionList.appendChild(li);
      });
    } else {
      const li = document.createElement('li');
      li.textContent = 'No suggestions available';
      suggestionList.appendChild(li);
    }

    modalBody.appendChild(suggestionList);

    const modal = document.getElementById('feedback-modal');
    modal.classList.add('active');
  }

  function openCypherModal(item) {
    currentItemId = item.id;

    document.getElementById('modal-title').textContent = "Cypher Query";
    document.getElementById('modal-username').textContent = `User: ${item.user}`;
    document.getElementById('modal-datetime').textContent = `Date: ${formatDateTime(item.datetime)}`;

    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = '';

    const cypherList = document.createElement('ul');
    cypherList.className = 'cypher-list';

    if (item.cypherQueries && item.cypherQueries.length > 0) {
      item.cypherQueries.forEach(query => {
        const li = document.createElement('li');
        li.textContent = query;
        cypherList.appendChild(li);
      });
    } else {
      const li = document.createElement('li');
      li.textContent = 'No Cypher queries available';
      cypherList.appendChild(li);
    }

    modalBody.appendChild(cypherList);

    const modal = document.getElementById('feedback-modal');
    modal.classList.add('active');
  }

  function closeModal() {
    const modal = document.getElementById('feedback-modal');
    modal.classList.remove('active');
    currentItemId = null;
  }

  function convertMongoDataToAppFormat(mongoData) {
    if (!mongoData || !Array.isArray(mongoData)) {
      console.error("Invalid MongoDB data:", mongoData);
      return [];
    }

    try {
      return mongoData.map(item => {
        try {
          console.log("Processing item:", item);

          let parsedMessages = parseMessages(item.messages || "[]");

          const firstUserMessage = parsedMessages.length > 0 ?
                  parsedMessages.find(msg => msg.role === 'user') : null;
          const question = firstUserMessage ? firstUserMessage.message : 'No question found';

          let suggestions = [];
          try {
            if (item.entitySuggesterData && item.entitySuggesterData !== "[]") {
              console.log("Processing entitySuggesterData:", item.entitySuggesterData);

              if (typeof item.entitySuggesterData === 'string') {
                const cleanedData = item.entitySuggesterData
                        .replace(/=/g, ':')
                        .replace(/'/g, '"');

                try {
                  const parsedData = JSON.parse(cleanedData);

                  if (Array.isArray(parsedData)) {
                    parsedData.forEach(entry => {
                      if (entry && entry.suggestion && entry.suggestion !== 'null') {
                        suggestions.push(entry.suggestion);
                      } else if (entry && entry.text && entry.text !== 'null') {
                        suggestions.push(entry.text);
                      } else if (entry && typeof entry === 'string') {
                        suggestions.push(entry);
                      }
                    });
                  }
                } catch (jsonError) {
                  console.warn("Error parsing entitySuggesterData as JSON", jsonError);

                  const suggestionMatches = item.entitySuggesterData.match(/suggestion=([^,}]+)/g);
                  if (suggestionMatches) {
                    suggestionMatches.forEach(match => {
                      const value = match.replace('suggestion=', '').trim();
                      if (value && value !== 'null') {
                        suggestions.push(value);
                      }
                    });
                  }
                }
              }
            }
          } catch (suggErr) {
            console.warn("Error processing suggestions:", suggErr);
          }

          let cypherQueries = [];
          if (item.sql_query) {
            if (typeof item.sql_query === 'string' && item.sql_query.trim() !== '') {
              cypherQueries = [item.sql_query];
            }
          } else {
            try {
              if (item.agentHistoryFilteredData && item.agentHistoryFilteredData.includes('content=MATCH')) {
                const match = item.agentHistoryFilteredData.match(/content=(MATCH[^}]+)/);
                if (match && match[1]) {
                  cypherQueries = [match[1].trim()];
                }
              }
            } catch (queryErr) {
              console.warn("Error extracting query from history:", queryErr);
            }
          }

          let timestamp;
          if (item.timestamp) {
            timestamp = typeof item.timestamp === 'number' ?
                    item.timestamp :
                    (typeof item.timestamp === 'string' ? parseInt(item.timestamp) : null);
          } else if (item.RDate && item.RDate.$date) {
            timestamp = new Date(item.RDate.$date).getTime();
          } else {
            timestamp = Date.now();
          }

          const date = new Date(timestamp);
          const formattedDate = isNaN(date.getTime()) ? 'Invalid date' :
                  date.toLocaleDateString() + ' ' + date.toLocaleTimeString();

          const id = item._id?.$oid ||
                  (typeof item._id === 'string' ? item._id : null) ||
                  item.uuid ||
                  `temp-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

          const hasAgentHistoryData = Boolean(item.agentHistoryFilteredData) &&
                  item.agentHistoryFilteredData !== "[]" &&
                  item.agentHistoryFilteredData !== undefined &&
                  String(item.agentHistoryFilteredData).length > 2;

          const hasContractIds = Boolean(item.contract_ids) &&
                  item.contract_ids !== "[]" &&
                  item.contract_ids !== undefined &&
                  String(item.contract_ids).length > 2;

          const hasDocumentIds = Boolean(item.document_ids) &&
                  item.document_ids !== "[]" &&
                  item.document_ids !== undefined &&
                  String(item.document_ids).length > 2;

          const hasEntitySuggesterData = Boolean(item.entitySuggesterData) &&
                  item.entitySuggesterData !== "[]" &&
                  item.entitySuggesterData !== undefined &&
                  String(item.entitySuggesterData).length > 2;

          return {
            id: id,
            schema: item.schema || '',
            question: question,
            conversation: parsedMessages,
            suggestions: suggestions,
            cypherQueries: cypherQueries,
            feedback: item.feedback || null,
            hidden: item.hidden || false,
            user: item.userName || 'Unknown',
            datetime: formattedDate,
            timestamp: timestamp,
            agentHistoryFilteredData: item.agentHistoryFilteredData || "[]",
            contractIds: item.contract_ids || "[]",
            documentIds: item.document_ids || "[]",
            entitySuggesterData: item.entitySuggesterData || "[]",
            hasAgentHistoryData: hasAgentHistoryData,
            hasContractIds: hasContractIds,
            hasDocumentIds: hasDocumentIds,
            hasEntitySuggesterData: hasEntitySuggesterData
          };
        } catch (itemError) {
          console.error("Error converting item:", itemError, item);
          return null;
        }
      }).filter(Boolean);
    } catch (error) {
      console.error("Error converting MongoDB data:", error);
      return [];
    }
  }

  function parseMessages(messagesString) {
    try {
      console.log("Parsing messages:", messagesString);

      if (!messagesString) {
        console.warn('Messages is null or undefined');
        return [
          { role: 'user', message: 'No messages available' }
        ];
      }

      if (typeof messagesString !== 'string') {
        console.warn('Messages is not a string:', messagesString);
        return [
          { role: 'user', message: 'Message parsing error' },
          { role: 'assistant', message: 'Unable to parse messages' }
        ];
      }

      if (messagesString.includes('role=') && messagesString.includes('content=')) {
        try {
          let cleanedString = messagesString
                  .replace(/^\[|\]$/g, '')
                  .replace(/\}\s*,\s*\{/g, '}|||{');

          const messageParts = cleanedString.split('|||');

          return messageParts.map(part => {
            const roleMatch = part.match(/role=([^,}]+)/);
            const role = roleMatch ? roleMatch[1].trim() : 'unknown';

            const contentMatch = part.match(/content=(.*?)(?=\s*,\s*\w+=|\s*\}|\s*$)/s);
            let message = contentMatch ? contentMatch[1].trim() : 'No content';

            if (message.startsWith('"') && !message.endsWith('"') && !message.endsWith('"}')) {
              message += '"';
            }

            message = message.replace(/^\{|\}$/g, '').trim();
            message = message.replace(/^"|"$/g, '').trim();

            return { role, message };
          });
        } catch (formatError) {
          console.error("Error parsing new message format:", formatError);
        }
      }

      try {
        const parsedJson = JSON.parse(messagesString);
        if (Array.isArray(parsedJson)) {
          return parsedJson.map(msg => ({
            role: msg.role || 'unknown',
            message: msg.content || 'No content'
          }));
        }
      } catch (jsonError) {
        console.warn("JSON parsing failed:", jsonError.message);
      }

      try {
        let jsonLikeString = messagesString
                .replace(/([a-zA-Z]+)=/g, '"$1":')
                .replace(/'/g, '"');

        const parsedJson = JSON.parse(jsonLikeString);
        if (Array.isArray(parsedJson)) {
          return parsedJson.map(msg => ({
            role: msg.role || 'unknown',
            message: msg.content || 'No content'
          }));
        }
      } catch (jsonError2) {
        console.warn('Failed with replacements too:', jsonError2.message);
      }

      try {
        const matches = messagesString.match(/\{role=(.*?), content=(.*?)(\},|\}$)/gs);
        if (matches && matches.length > 0) {
          return matches.map(match => {
            const roleMatch = match.match(/role=(.*?),/);
            const contentMatch = match.match(/content=(.*?)(\},|\}$)/s);

            return {
              role: roleMatch ? roleMatch[1].trim() : 'unknown',
              message: contentMatch ? contentMatch[1].trim() : 'Error parsing message'
            };
          });
        }
      } catch (regexError) {
        console.warn('Regex parsing failed:', regexError.message);
      }

      console.warn("Using fallback parsing for:", messagesString.substring(0, 50) + "...");
      return [
        { role: 'user', message: 'Error parsing message' },
        { role: 'assistant', message: 'Error parsing message' }
      ];
    } catch (error) {
      console.error("Critical error parsing messages:", error);
      return [
        { role: 'user', message: 'Error parsing message' },
        { role: 'assistant', message: 'Error parsing message' }
      ];
    }
  }

  async function connectToMongoDB(page = 0) {
    try {
      connectionIndicator.classList.remove('connected');
      connectionIndicator.classList.remove('disconnected');
      connectionText.textContent = `Connecting to MongoDB (page ${page + 1})...`;

      // Get elements safely
      const connectionIndicator = getElement('connection-indicator', true);
      const connectionText = getElement('connection-text', true);

      data = [];
      filteredData = [];

      const response = await fetch(`${API_BASE_URL}/conversations?page=${page}&limit=${pageSize}`);

      if (!response.ok) {
        throw new Error(`API responded with status: ${response.status}`);
      }

      const result = await response.json();
      console.log("API response:", result);

      let mongoData;
      if (result.data) {
        mongoData = result.data;

        currentPage = result.pagination.page;
        totalPages = result.pagination.totalPages;
      } else {
        mongoData = result;
        currentPage = 0;
        totalPages = 1;
      }

      connectionIndicator.classList.add('connected');
      connectionText.textContent = `Connected to MongoDB - ${mongoData.length} records loaded`;

      if (result.pagination) {
        connectionText.textContent += ` (Page ${currentPage + 1} of ${totalPages} - Total: ${result.pagination.totalCount})`;
      }

      data = convertMongoDataToAppFormat(mongoData);
      console.log("Converted data:", data);

      filteredData = [...data.filter(item => !item.hidden)];

      console.log("API response received:", result);
      console.log("Converted data length:", data.length);
      console.log("First item:", data[0]);

      initializeTabs(totalPages);

      renderItems();

    } catch (error) {
      console.error('Error connecting to MongoDB:', error);
      connectionIndicator.classList.add('disconnected');
      connectionText.textContent = 'Failed to connect to MongoDB: ' + error.message;
    }
  }

  function initializeTabs(totalPages) {
    const tabsList = document.getElementById('tabs-list');
    const prevTabBtn = document.getElementById('prev-tab-btn');
    const nextTabBtn = document.getElementById('next-tab-btn');

    if (!tabsList || !prevTabBtn || !nextTabBtn) return;

    tabsList.innerHTML = '';

    for (let i = 0; i < totalPages; i++) {
      const tab = document.createElement('button');
      tab.className = `pagination-btn${currentPage === i ? ' active' : ''}`;
      tab.textContent = `Page ${i + 1}`;
      tab.dataset.page = i;

      tab.addEventListener('click', () => {
        if (currentPage !== i) {
          loadPage(i);
        }
      });

      tabsList.appendChild(tab);
    }

    updateTabsVisibility();

    prevTabBtn.disabled = currentPage === 0;
    nextTabBtn.disabled = currentPage === totalPages - 1;

    prevTabBtn.addEventListener('click', () => {
      if (currentPage > 0) {
        loadPage(currentPage - 1);
      }
    });

    nextTabBtn.addEventListener('click', () => {
      if (currentPage < totalPages - 1) {
        loadPage(currentPage + 1);
      }
    });
  }

  async function loadPage(page) {
    connectionText.textContent = `Loading page ${page + 1}...`;

    try {
      const response = await fetch(`${API_BASE_URL}/conversations?page=${page}&limit=${pageSize}`);

      if (!response.ok) {
        throw new Error(`API responded with status: ${response.status}`);
      }

      const result = await response.json();
      const mongoData = result.data;

      currentPage = page;

      data = convertMongoDataToAppFormat(mongoData);
      filteredData = [...data.filter(item => !item.hidden)];

      const tabButtons = document.querySelectorAll('.pagination-btn');
      tabButtons.forEach(tab => {
        const tabPage = parseInt(tab.dataset.page);
        tab.classList.toggle('active', tabPage === currentPage);
      });

      updateTabsVisibility();

      document.getElementById('prev-tab-btn').disabled = currentPage === 0;
      document.getElementById('next-tab-btn').disabled = currentPage === totalPages - 1;

      connectionText.textContent = `Page ${currentPage + 1} of ${totalPages} - Total records: ${result.pagination.totalCount}`;

      renderItems();

    } catch (error) {
      console.error('Error loading page:', error);
      connectionText.textContent = `Failed to load page ${page + 1}: ${error.message}`;
    }
  }

  function updateTabsVisibility() {
    const tabButtons = document.querySelectorAll('.pagination-btn');

    let startIndex = Math.max(0, currentPage - Math.floor(visibleTabCount / 2));
    let endIndex = Math.min(totalPages - 1, startIndex + visibleTabCount - 1);

    if (endIndex - startIndex + 1 < visibleTabCount) {
      startIndex = Math.max(0, endIndex - visibleTabCount + 1);
    }

    tabButtons.forEach((tab, index) => {
      tab.style.display = (index >= startIndex && index <= endIndex) ? 'block' : 'none';
    });
  }

  // Fix for schema buttons detection (add after the getElement function, around line 480)

  // Function to ensure schema buttons exist
  function ensureSchemaButtonsExist() {
    console.log('Checking and ensuring schema buttons exist...');

    // Get the schema filters container
    const schemaFilters = getElement('schema-filters', true);

    // Check if schema buttons already exist
    const existingButtons = schemaFilters.querySelectorAll('.filter-btn[data-schema]');

    if (existingButtons.length === 0) {
      console.log('No schema buttons found, creating them...');

      // Create schema buttons
      schemaList.forEach(schema => {
        const button = document.createElement('button');
        button.className = 'filter-btn';
        button.dataset.schema = schema;
        button.textContent = schema;

        // Add event listener for schema filtering
        button.addEventListener('click', () => {
          filterBySchema(schema);
        });

        // Add to container
        schemaFilters.appendChild(button);
      });

      console.log(`Created ${schemaList.length} schema buttons`);
    } else {
      console.log(`Found ${existingButtons.length} existing schema buttons`);
    }
  }

  // Call this function early to ensure buttons exist
  document.addEventListener('DOMContentLoaded', function() {
    // Execute with short delay to ensure DOM is ready
    setTimeout(ensureSchemaButtonsExist, 100);

    // Also patch the feedback-system-fixes.js detection
    window.addEventListener('load', function() {
      // Suppress the schema buttons warning by overriding console.error
      const originalConsoleError = console.error;
      console.error = function(...args) {
        // Check if this is the specific error we want to suppress
        if (args[0] === 'No schema buttons found. This might cause reference errors.') {
          console.warn('Suppressed schema buttons warning, buttons will be created');
          // Create buttons if they don't exist
          ensureSchemaButtonsExist();
        } else {
          // Pass through to original console.error
          originalConsoleError.apply(console, args);
        }
      };

      // Restore original after a delay
      setTimeout(() => {
        console.error = originalConsoleError;
      }, 2000);
    });
  });


  // Add this fix near the top of your script (around line 390, before most other code)

  // Global proxy for connectionIndicator and connectionText
  (function() {
    // Create global accessor for connection elements
    Object.defineProperty(window, 'connectionIndicator', {
      get: function() {
        const element = document.getElementById('connection-indicator');
        if (!element) {
          console.warn('Accessing undefined connectionIndicator, creating on demand');
          // Create the element on demand
          const newElement = document.createElement('div');
          newElement.id = 'connection-indicator';
          newElement.className = 'status-indicator';

          // Find connection status container or create it
          let container = document.querySelector('.connection-status');
          if (!container) {
            container = document.createElement('div');
            container.className = 'connection-status';
            document.body.insertBefore(container, document.body.firstChild);
          }

          container.appendChild(newElement);
          return newElement;
        }
        return element;
      },
      configurable: true
    });

    Object.defineProperty(window, 'connectionText', {
      get: function() {
        const element = document.getElementById('connection-text');
        if (!element) {
          console.warn('Accessing undefined connectionText, creating on demand');
          // Create the element on demand
          const newElement = document.createElement('span');
          newElement.id = 'connection-text';
          newElement.textContent = 'Connecting to MongoDB...';

          // Find connection status container or create it
          let container = document.querySelector('.connection-status');
          if (!container) {
            container = document.createElement('div');
            container.className = 'connection-status';
            document.body.insertBefore(container, document.body.firstChild);
          }

          container.appendChild(newElement);
          return newElement;
        }
        return element;
      },
      configurable: true
    });

    // Connect to MongoDB function wrapper
    const originalConnectToMongoDB = window.connectToMongoDB;
    window.connectToMongoDB = function(page = 0) {
      try {
        // Make sure variables are defined
        const connectionIndicator = window.connectionIndicator;
        const connectionText = window.connectionText;

        // Call original if exists
        if (typeof originalConnectToMongoDB === 'function') {
          return originalConnectToMongoDB(page);
        } else {
          console.error('Original connectToMongoDB function not found');
          connectionText.textContent = 'Error: MongoDB connection function not found';
          return Promise.reject(new Error('MongoDB connection function not found'));
        }
      } catch (error) {
        console.error('Error in connectToMongoDB wrapper:', error);
        return Promise.reject(error);
      }
    };
  })();

  // Add a patch for pagination-fix.js's connectToMongoDB function
  document.addEventListener('DOMContentLoaded', function() {
    // Create a MutationObserver to watch for script tags
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type !== 'childList') continue;

        for (const node of mutation.addedNodes) {
          if (node.nodeName !== 'SCRIPT') continue;

          // Check if this is pagination-fix.js
          if (node.src && node.src.includes('pagination-fix.js')) {
            console.log('Detected pagination-fix.js loading, preparing patch...');

            // Wait for script to load and execute
            node.addEventListener('load', () => {
              console.log('Patching pagination-fix.js...');

              // Store original connectToMongoDB if it exists at this point
              const originalConnectToMongoDB = window.connectToMongoDB;

              // Define a new safe version
              window.connectToMongoDB = function(page = 0) {
                try {
                  console.log('Safe connectToMongoDB called from pagination-fix.js');

                  // Ensure we have connection elements
                  const connectionIndicator = window.connectionIndicator;
                  const connectionText = window.connectionText;

                  // Show connecting status safely
                  if (connectionIndicator && connectionIndicator.classList) {
                    connectionIndicator.classList.remove('connected');
                    connectionIndicator.classList.remove('disconnected');
                  }

                  if (connectionText) {
                    connectionText.textContent = `Connecting to MongoDB (page ${page + 1})...`;
                  }

                  // Call original if it exists
                  if (typeof originalConnectToMongoDB === 'function') {
                    return originalConnectToMongoDB(page);
                  } else {
                    console.error('Original connectToMongoDB function not found after patching');
                    if (connectionText) {
                      connectionText.textContent = 'Error: MongoDB connection function not found';
                    }
                  }
                } catch (error) {
                  console.error('Error in patched connectToMongoDB:', error);
                }
              };
            });
          }
        }
      }
    });

    // Start observing document for script additions
    observer.observe(document, { childList: true, subtree: true });

    // Disconnect after a reasonable timeout
    setTimeout(() => observer.disconnect(), 10000);
  });

  // Add this patch after the global variables declaration (around line 420)

  // Patch for pagination-fix.js to handle missing activeTypeFilter
  document.addEventListener('DOMContentLoaded', function() {
    // Ensure activeTypeFilter is defined
    window.activeTypeFilter = null;

    // Patch the applyFilters function to handle missing type filter
    const patchApplyFilters = function() {
      // Get original function
      const originalApplyFilters = window.applyFilters;

      if (typeof originalApplyFilters === 'function') {
        console.log('Patching applyFilters function to handle missing typeFilter...');

        window.applyFilters = async function() {
          try {
            // Build query parameters for server-side filtering
            const queryParams = new URLSearchParams();

            // Add page and limit
            queryParams.append('page', window.currentPage || 0);
            queryParams.append('limit', window.pageSize || 20);

            // Add active filters
            if (window.activeSchema) {
              queryParams.append('schema', window.activeSchema);
            }

            // PATCH: Skip type filter if not defined
            // Original code:
            // if (activeTypeFilter) {
            //   queryParams.append('type', activeTypeFilter);
            // }

            // Instead use global variable or default to null
            if (window.activeTypeFilter) {
              queryParams.append('type', window.activeTypeFilter);
            }

            // Continue with rest of function...
            if (window.activeFeedbackFilter) {
              queryParams.append('feedback', window.activeFeedbackFilter);
            }

            // Add hidden filter
            queryParams.append('hidden', window.showHidden || false);

            // Add search query
            if (window.searchQuery) {
              queryParams.append('search', window.searchQuery);
            }

            // Call original function if exists
            return originalApplyFilters.apply(this, arguments);
          } catch (error) {
            console.error('Error in patched applyFilters:', error);

            // Fallback to client-side filtering
            console.log('Falling back to client-side filtering...');

            // Only client-side filter the current page data
            let filtered = [...window.data];

            // Apply schema filter if active
            if (window.activeSchema) {
              filtered = filtered.filter(item => item.schema === window.activeSchema);
            }

            // Apply feedback filter if active
            if (window.activeFeedbackFilter) {
              filtered = filtered.filter(item => item.feedback === window.activeFeedbackFilter);
            }

            // Apply hidden filter
            if (!window.showHidden) {
              filtered = filtered.filter(item => !item.hidden);
            }

            // Apply search query
            if (window.searchQuery) {
              filtered = filtered.filter(item =>
                      (item.question && item.question.toLowerCase().includes(window.searchQuery)) ||
                      (item.query && item.query.toLowerCase().includes(window.searchQuery))
              );
            }

            window.filteredData = filtered;
            window.renderItems();
          }
        };
      }
    };

    // Execute patch immediately
    patchApplyFilters();

    // Also patch on window load to ensure it runs after all scripts
    window.addEventListener('load', patchApplyFilters);

    // Patch for continuous-loading-fix.js
    const patchContinuousLoadingFix = function() {
      // Make sure optimizeFilterApplication function is safe
      if (typeof window.optimizeFilterApplication === 'function') {
        console.log('Patching optimizeFilterApplication function...');

        const originalOptimizeFilterApplication = window.optimizeFilterApplication;

        window.optimizeFilterApplication = function() {
          try {
            // Ensure activeTypeFilter exists
            window.activeTypeFilter = window.activeTypeFilter || null;

            // Call original
            return originalOptimizeFilterApplication.apply(this, arguments);
          } catch (error) {
            console.error('Error in patched optimizeFilterApplication:', error);
          }
        };
      }
    };

    // Patch for continuous loading fix
    setTimeout(patchContinuousLoadingFix, 1000);
  });


  function filterBySchema(schema) {
    const button = document.querySelector(`.filter-btn[data-schema="${schema}"]`);

    if (!button) return;

    if (activeSchema === schema) {
      activeSchema = null;
      button.classList.remove('active');
    } else {
      document.querySelectorAll('.filter-btn[data-schema]').forEach(btn => {
        btn.classList.remove('active');
      });

      activeSchema = schema;
      button.classList.add('active');
    }

    applyFilters();
  }

  function applyFilters() {
    let filtered = [...data];

    if (activeSchema) {
      filtered = filtered.filter(item => item.schema === activeSchema);
    }

    if (activeFeedbackFilter) {
      filtered = filtered.filter(item => item.feedback === activeFeedbackFilter);
    }

    if (!showHidden) {
      filtered = filtered.filter(item => !item.hidden);
    }

    if (dateFrom || dateTo) {
      filtered = filtered.filter(item => {
        const itemDate = new Date(item.timestamp);

        if (dateFrom && dateTo) {
          return itemDate >= dateFrom && itemDate <= dateTo;
        } else if (dateFrom) {
          return itemDate >= dateFrom;
        } else if (dateTo) {
          return itemDate <= dateTo;
        }
        return true;
      });
    }

    if (searchQuery) {
      filtered = filtered.filter(item =>
              (item.question && item.question.toLowerCase().includes(searchQuery)) ||
              (item.conversation && item.conversation.some(msg =>
                      msg.message.toLowerCase().includes(searchQuery)
              )) ||
              (item.user && item.user.toLowerCase().includes(searchQuery))
      );
    }

    filtered.sort((a, b) => {
      const timeA = a.timestamp || 0;
      const timeB = b.timestamp || 0;

      return sortOrder === 'newest'
              ? timeB - timeA
              : timeA - timeB;
    });

    filteredData = filtered;
    renderItems();
  }

  function renderItems() {
    const feedbackItems = document.getElementById('feedback-items');
    const noResults = document.getElementById('no-results');
    const resultsCount = document.getElementById('results-count');

    console.log("Rendering items, filtered data length:", filteredData.length);

    if (!feedbackItems || !noResults || !resultsCount) return;

    resultsCount.textContent = `Showing ${Math.min(pageSize, filteredData.length)} of ${filteredData.length} results`;

    feedbackItems.innerHTML = '';

    if (filteredData.length === 0) {
      noResults.classList.remove('hidden');
    } else {
      noResults.classList.add('hidden');

      filteredData.slice(0, pageSize).forEach((item, index) => {
        const itemElement = document.createElement('div');
        itemElement.className = 'feedback-item';
        itemElement.dataset.id = item.id;

        const schemaButtons = document.createElement('div');
        schemaButtons.className = 'schema-buttons';

        schemaList.forEach(schema => {
          const button = document.createElement('button');
          button.className = `schema-btn${item.schema === schema ? ' active' : ''}`;
          button.textContent = schema;
          button.dataset.schema = schema;

          button.addEventListener('click', (e) => {
            e.stopPropagation();
            setSchema(item.id, schema);
          });

          schemaButtons.appendChild(button);
        });

        const contentArea = document.createElement('div');
        contentArea.className = 'feedback-content';

        const userInfo = document.createElement('div');
        userInfo.className = 'feedback-user-info';
        userInfo.innerHTML = `
          <span class="user-name">User: ${item.user}</span>
          <span class="datetime">${formatDateTime(item.datetime)}</span>
        `;
        contentArea.appendChild(userInfo);

        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'feedback-buttons';

        const conversationBtn = document.createElement('button');
        conversationBtn.className = 'conversation-btn';
        conversationBtn.textContent = item.question;
        conversationBtn.addEventListener('click', () => {
          openConversationModal(item);
        });

        const smallButtons = document.createElement('div');
        smallButtons.className = 'small-buttons';

        const suggestionBtn = document.createElement('button');
        suggestionBtn.className = 'suggestion-btn';
        suggestionBtn.textContent = 'Suggestion';
        suggestionBtn.addEventListener('click', () => {
          openSuggestionModal(item);
        });

        const cypherBtn = document.createElement('button');
        cypherBtn.className = 'cypher-btn';
        cypherBtn.textContent = 'Cypher Query';
        cypherBtn.addEventListener('click', () => {
          openCypherModal(item);
        });

        smallButtons.appendChild(suggestionBtn);
        smallButtons.appendChild(cypherBtn);

        buttonsContainer.appendChild(conversationBtn);
        buttonsContainer.appendChild(smallButtons);

        contentArea.appendChild(buttonsContainer);

        const additionalDataButtons = document.createElement('div');
        additionalDataButtons.className = 'additional-data-buttons';

        const agentHistoryBtn = document.createElement('button');
        agentHistoryBtn.className = 'data-btn agent-history-btn';
        agentHistoryBtn.disabled = !item.hasAgentHistoryData;
        agentHistoryBtn.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 8c-2.8 0-5 2.2-5 5s2.2 5 5 5 5-2.2 5-5-2.2-5-5-5Z"></path>
            <path d="M3 12c0-5.5 5.9-10 9-10"></path>
            <path d="M15 2v6h6"></path>
            <path d="M21 12c0 5.5-5.9 10-9 10"></path>
            <path d="M9 22v-6H3"></path>
          </svg>
          Agent History
        `;
        agentHistoryBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (item.hasAgentHistoryData) {
            openDataPopup('Agent History', item.agentHistoryFilteredData);
          }
        });

        const contractIdsBtn = document.createElement('button');
        contractIdsBtn.className = 'data-btn contract-ids-btn';
        contractIdsBtn.disabled = !item.hasContractIds;
        contractIdsBtn.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M14 3v4a1 1 0 0 0 1 1h4"></path>
            <path d="M17 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2Z"></path>
            <path d="M9 9h1"></path>
            <path d="M9 13h6"></path>
            <path d="M9 17h6"></path>
          </svg>
          Contract IDs
        `;
        contractIdsBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (item.hasContractIds) {
            openDataPopup('Contract IDs', item.contractIds);
          }
        });

        // Create document IDs button
        const documentIdsBtn = document.createElement('button');
        documentIdsBtn.className = 'data-btn document-ids-btn';
        documentIdsBtn.disabled = !item.hasDocumentIds;
        documentIdsBtn.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
            <polyline points="14 2 14 8 20 8"></polyline>
            <line x1="16" y1="13" x2="8" y2="13"></line>
            <line x1="16" y1="17" x2="8" y2="17"></line>
            <polyline points="10 9 9 9 8 9"></polyline>
          </svg>
          Document IDs
        `;
        documentIdsBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (item.hasDocumentIds) {
            openDataPopup('Document IDs', item.documentIds);
          }
        });

        // Create entity suggester button
        const entitySuggesterBtn = document.createElement('button');
        entitySuggesterBtn.className = 'data-btn entity-suggester-btn';
        entitySuggesterBtn.disabled = !item.hasEntitySuggesterData;
        entitySuggesterBtn.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
          </svg>
          Entity Data
        `;
        entitySuggesterBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (item.hasEntitySuggesterData) {
            openDataPopup('Entity Suggester Data', item.entitySuggesterData);
          }
        });

        // Add buttons to container
        additionalDataButtons.appendChild(agentHistoryBtn);
        additionalDataButtons.appendChild(contractIdsBtn);
        additionalDataButtons.appendChild(documentIdsBtn);
        additionalDataButtons.appendChild(entitySuggesterBtn);

        // Add additional data buttons to the content area
        contentArea.appendChild(additionalDataButtons);

        // Create the actions column
        const actions = document.createElement('div');
        actions.className = 'feedback-actions';

        // Positive button (thumbs up)
        const positiveBtn = document.createElement('button');
        positiveBtn.className = `action-btn positive${item.feedback === 'positive' ? ' active' : ''}`;
        positiveBtn.dataset.action = 'positive';
        positiveBtn.innerHTML = `
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M7 10v12"></path>
            <path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z"></path>
          </svg>
        `;

        positiveBtn.addEventListener('click', (e) => {
          e.stopPropagation(); // Don't open the modal
          handlePositiveFeedback(item.id);
        });

        // Archive button (now in middle position)
        const archiveBtn = document.createElement('button');
        archiveBtn.className = `action-btn archive${item.hidden ? ' active' : ''}`;
        archiveBtn.dataset.action = 'archive';
        archiveBtn.innerHTML = `
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect width="20" height="5" x="2" y="3" rx="1"></rect>
            <path d="M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8"></path>
            <path d="M10 12h4"></path>
          </svg>
        `;

        archiveBtn.addEventListener('click', (e) => {
          e.stopPropagation(); // Don't open the modal
          handleToggleHidden(item.id);
        });

        // Negative button (thumbs down) - now last
        const negativeBtn = document.createElement('button');
        negativeBtn.className = `action-btn negative${item.feedback === 'negative' ? ' active' : ''}`;
        negativeBtn.dataset.action = 'negative';
        negativeBtn.innerHTML = `
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M17 14V2"></path>
            <path d="M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22h0a3.13 3.13 0 0 1-3-3.88Z"></path>
          </svg>
        `;

        negativeBtn.addEventListener('click', (e) => {
          e.stopPropagation(); // Don't open the modal
          handleNegativeFeedback(item.id);
        });

        // Add action buttons to actions container in the new order
        actions.appendChild(positiveBtn);
        actions.appendChild(archiveBtn);
        actions.appendChild(negativeBtn);

        // Add all parts to the item
        itemElement.appendChild(schemaButtons);
        itemElement.appendChild(contentArea);
        itemElement.appendChild(actions);

        // Add to the container
        feedbackItems.appendChild(itemElement);
      });
    }
  }

  // Create a popup for displaying additional data
  function openDataPopup(title, data) {
    // Check if a popup already exists and remove it
    const existingPopup = document.getElementById('data-popup');
    if (existingPopup) {
      existingPopup.remove();
    }

    // Create popup container
    const popup = document.createElement('div');
    popup.id = 'data-popup';
    popup.className = 'data-popup';
    popup.setAttribute('role', 'dialog');
    popup.setAttribute('aria-labelledby', 'popup-title');
    popup.setAttribute('aria-modal', 'true');

    // Create popup content
    const popupContent = document.createElement('div');
    popupContent.className = 'popup-content';

    // Create header
    const popupHeader = document.createElement('div');
    popupHeader.className = 'popup-header';

    // Create title
    const popupTitle = document.createElement('h3');
    popupTitle.id = 'popup-title';
    popupTitle.textContent = title;
    popupHeader.appendChild(popupTitle);

    // Create button container for header
    const headerButtons = document.createElement('div');
    headerButtons.className = 'popup-header-buttons';

    // Create copy button
    const copyButton = document.createElement('button');
    copyButton.className = 'popup-copy';
    copyButton.title = 'Copy to clipboard';
    copyButton.innerHTML = `
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
    </svg>
  `;
    copyButton.addEventListener('click', () => {
      let textToCopy = typeof data === 'object' ? JSON.stringify(data, null, 2) : data;
      navigator.clipboard.writeText(textToCopy)
              .then(() => {
                copyButton.classList.add('success');
                setTimeout(() => copyButton.classList.remove('success'), 1500);
              })
              .catch(err => console.error('Failed to copy: ', err));
    });
    headerButtons.appendChild(copyButton);

    // Create close button
    const closeButton = document.createElement('button');
    closeButton.className = 'popup-close';
    closeButton.title = 'Close';
    closeButton.setAttribute('aria-label', 'Close');
    closeButton.innerHTML = `
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <line x1="18" y1="6" x2="6" y2="18"></line>
      <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
  `;
    closeButton.addEventListener('click', () => closePopup(popup));
    headerButtons.appendChild(closeButton);

    popupHeader.appendChild(headerButtons);
    popupContent.appendChild(popupHeader);

    // Create body
    const popupBody = document.createElement('div');
    popupBody.className = 'popup-body';

    // Format and add the data
    let formattedData;
    try {
      // Handle if data is already an object
      if (typeof data === 'object' && data !== null) {
        formattedData = `<pre>${JSON.stringify(data, null, 2)}</pre>`;
      }
      // Try to parse JSON if it's a string
      else if (typeof data === 'string') {
        try {
          const parsedData = JSON.parse(data);
          formattedData = `<pre>${JSON.stringify(parsedData, null, 2)}</pre>`;
        } catch {
          // If not valid JSON, display as formatted text
          formattedData = `<pre>${data}</pre>`;
        }
      } else {
        formattedData = `<pre>${String(data)}</pre>`;
      }
    } catch (e) {
      formattedData = `<pre>Error displaying data: ${e.message}</pre>`;
    }

    popupBody.innerHTML = formattedData;
    popupContent.appendChild(popupBody);

    // Add content to popup
    popup.appendChild(popupContent);

    // Add popup to body
    document.body.appendChild(popup);

    // Trap focus in modal for accessibility
    const focusableElements = popup.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    const firstElement = focusableElements[0];
    if (firstElement) firstElement.focus();

    // Animate the popup
    setTimeout(() => popup.classList.add('active'), 10);

    // Close popup function
    function closePopup(element) {
      element.classList.remove('active');
      setTimeout(() => element.remove(), 300);
    }

    // Add click outside to close
    popup.addEventListener('click', (e) => {
      if (e.target === popup) closePopup(popup);
    });

    // Add escape key to close
    const escapeHandler = (e) => {
      if (e.key === 'Escape') {
        closePopup(popup);
        document.removeEventListener('keydown', escapeHandler);
      }
    };
    document.addEventListener('keydown', escapeHandler);
  }

  // Handle positive feedback
  async function handlePositiveFeedback(id) {
    const item = data.find(item => item.id === id);
    if (!item) return;

    // If already positive, remove feedback
    const newFeedback = item.feedback === 'positive' ? null : 'positive';

    // Update data locally first
    data = data.map(item => {
      if (item.id === id) {
        return { ...item, feedback: newFeedback };
      }
      return item;
    });

    // Update MongoDB via API
    try {
      const response = await fetch(`${API_BASE_URL}/conversations/${id}/feedback`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ feedback: newFeedback })
      });

      if (!response.ok) {
        console.error('Error updating feedback:', await response.text());
      } else if (newFeedback === 'positive') {
        // Show QDrant confirmation dialog
        showQdrantConfirmDialog(item);
      }
    } catch (error) {
      console.error('Failed to update feedback:', error);
    }

    // Apply filters to update UI
    applyFilters();
  }

  // Handle negative feedback
  async function handleNegativeFeedback(id) {
    const item = data.find(item => item.id === id);
    if (!item) return;

    // If already negative, remove feedback
    const newFeedback = item.feedback === 'negative' ? null : 'negative';

    // Update data locally first
    data = data.map(item => {
      if (item.id === id) {
        return { ...item, feedback: newFeedback };
      }
      return item;
    });

    // Update MongoDB via API
    try {
      const response = await fetch(`${API_BASE_URL}/conversations/${id}/feedback`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ feedback: newFeedback })
      });

      if (!response.ok) {
        console.error('Error updating feedback:', await response.text());
      }
    } catch (error) {
      console.error('Failed to update feedback:', error);
    }

    // Apply filters to update UI
    applyFilters();
  }

  // Handle toggle hidden
  async function handleToggleHidden(id) {
    const item = data.find(item => item.id === id);
    if (!item) return;

    // Toggle hidden state
    const newHiddenState = !item.hidden;

    // Update data locally first
    data = data.map(item => {
      if (item.id === id) {
        return { ...item, hidden: newHiddenState };
      }
      return item;
    });

    // Update MongoDB via API
    try {
      const response = await fetch(`${API_BASE_URL}/conversations/${id}/archive`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ hidden: newHiddenState })
      });

      if (!response.ok) {
        console.error('Error updating archive status:', await response.text());
      }
    } catch (error) {
      console.error('Failed to update archive status:', error);
    }

    // Apply filters to update UI
    applyFilters();
  }

  // Set schema for an item
  async function setSchema(id, schema) {
    const item = data.find(item => item.id === id);
    if (!item) return;

    // Update schema locally first
    const oldSchema = item.schema;
    item.schema = schema;

    // Update schema buttons in this item
    const itemElement = document.querySelector(`.feedback-item[data-id="${id}"]`);
    if (itemElement) {
      const schemaButtons = itemElement.querySelectorAll('.schema-btn');
      schemaButtons.forEach(button => {
        const buttonSchema = button.dataset.schema;
        button.classList.toggle('active', buttonSchema === schema);
      });
    }

    // Update MongoDB via API
    try {
      const response = await fetch(`${API_BASE_URL}/conversations/${id}/schema`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ schema })
      });

      if (!response.ok) {
        console.error('Error updating schema:', await response.text());
        // Revert to old schema if update failed
        item.schema = oldSchema;
        if (itemElement) {
          const schemaButtons = itemElement.querySelectorAll('.schema-btn');
          schemaButtons.forEach(button => {
            const buttonSchema = button.dataset.schema;
            button.classList.toggle('active', buttonSchema === oldSchema);
          });
        }
        alert('Failed to update schema on server. Please try again.');
        return;
      }

      // Apply filters to update UI if needed
      if (activeSchema) {
        applyFilters();
      }
    } catch (error) {
      console.error('Failed to update schema:', error);
      // Revert to old schema if update failed
      item.schema = oldSchema;
      if (itemElement) {
        const schemaButtons = itemElement.querySelectorAll('.schema-btn');
        schemaButtons.forEach(button => {
          const buttonSchema = button.dataset.schema;
          button.classList.toggle('active', buttonSchema === oldSchema);
        });
      }
      alert('Failed to update schema: ' + error.message);
    }
  }

  // Show QDrant confirmation dialog
  function showQdrantConfirmDialog(item) {
    // Create dialog
    const dialog = document.createElement('div');
    dialog.className = 'qdrant-confirm-dialog';
    dialog.innerHTML = `
    <div class="qdrant-confirm-content">
      <h3 class="qdrant-confirm-title">Add to QDrant</h3>
      <p class="qdrant-confirm-text">Would you like to add this question to QDrant?</p>
      <div class="qdrant-confirm-buttons">
        <button class="qdrant-confirm-btn cancel">Cancel</button>
        <button class="qdrant-confirm-btn confirm">Add to QDrant</button>
      </div>
    </div>
  `;

    // Add event listeners
    const cancelBtn = dialog.querySelector('.cancel');
    const confirmBtn = dialog.querySelector('.confirm');

    cancelBtn.addEventListener('click', () => {
      dialog.remove();
    });

    confirmBtn.addEventListener('click', () => {
      dialog.remove();
      fillQdrantForm(item);
    });

    document.body.appendChild(dialog);
  }

  // Fill QDrant form and scroll to top
  function fillQdrantForm(item) {
    // Get the form elements
    const questionTextarea = document.getElementById('qdrant-question');
    const cypherTextarea = document.getElementById('qdrant-cypher');

    // Fill with data
    questionTextarea.value = item.question || '';

    // Fill cypher query if available
    if (item.cypherQueries && item.cypherQueries.length > 0) {
      cypherTextarea.value = item.cypherQueries[0] || '';
    } else {
      cypherTextarea.value = '';
    }

    // Scroll to top smoothly
    window.scrollTo({ top: 0, behavior: 'smooth' });

    // Highlight the textareas
    questionTextarea.classList.add('highlighted');
    cypherTextarea.classList.add('highlighted');

    // Remove highlight after animation
    setTimeout(() => {
      questionTextarea.classList.remove('highlighted');
      cypherTextarea.classList.remove('highlighted');
    }, 2000);
  }

  // Event listener for the "Send to QDrant" button
  document.addEventListener('DOMContentLoaded', function() {
    const sendToQdrantBtn = document.getElementById('send-to-qdrant');

    if (sendToQdrantBtn) {
      sendToQdrantBtn.addEventListener('click', function() {
        // For demo purposes - just clear the form and show an alert
        const questionTextarea = document.getElementById('qdrant-question');
        const cypherTextarea = document.getElementById('qdrant-cypher');

        alert('Data sent to QDrant (Demo)');

        // Clear the form
        questionTextarea.value = '';
        cypherTextarea.value = '';
      });
    }
  });
</script>

<!-- Include fix scripts -->
<script src="comprehensive-fix.js"></script>
<script src="comprehensive-fix-2.js"></script>
<script src="ui-debug-tool.js"></script>
<script src="continuous-loading-fix.js"></script>
<script src="feedback-system-fixes.js"></script>
<script src="feedback-system-fixes-2.js"></script>
<script src="pagination-fix.js"></script>
<script src="similarity-fix.js"></script>
<script src="debug-mode.js"></script>
</body>
</html>