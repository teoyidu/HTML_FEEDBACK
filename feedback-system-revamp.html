<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Chatbot Feedback System</title>
  <style>
    /* General styles */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background-color: #111827;
      color: #f3f4f6;
      line-height: 1.5;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
    }

    h1 {
      font-size: 1.5rem;
      font-weight: bold;
      margin-bottom: 1.5rem;
    }

    /* Search bar */
    .search-container {
      position: relative;
      margin-bottom: 1.5rem;
    }

    .search-icon {
      position: absolute;
      left: 0.75rem;
      top: 50%;
      transform: translateY(-50%);
      color: #9ca3af;
    }

    .search-input {
      width: 100%;
      padding: 0.625rem 0.75rem 0.625rem 2.5rem;
      background-color: #1f2937;
      border: 1px solid #374151;
      border-radius: 0.5rem;
      color: #f3f4f6;
      font-size: 0.875rem;
    }

    .search-input:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 1px #3b82f6;
    }

    /* Filter styles */
    .filter-section {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }

    .filter-label {
      display: flex;
      align-items: center;
      margin-right: 0.5rem;
    }

    .filter-label svg {
      margin-right: 0.25rem;
    }

    .filter-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .filter-btn {
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.875rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: none;
      cursor: pointer;
      transition: background-color 0.2s;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .filter-btn:hover {
      background-color: #374151;
    }

    .filter-btn.active {
      background-color: #2563eb;
      color: white;
    }

    /* Feedback filters */
    .feedback-filters {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      border-top: 1px solid #374151;
      padding-top: 1rem;
    }

    /* Page size buttons */
    .page-size {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      align-items: center;
    }

    .page-size-btn {
      padding: 0.25rem 0.75rem;
      border-radius: 0.25rem;
      font-size: 0.875rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: none;
      cursor: pointer;
    }

    .page-size-btn.active {
      background-color: #374151;
      color: white;
    }

    /* Results count */
    .results-count {
      margin-bottom: 1rem;
      color: #9ca3af;
      font-size: 0.875rem;
    }

    /* MongoDB Connection Styles */
    .connection-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
      font-size: 0.875rem;
    }

    .connection-status .status-indicator {
      width: 0.75rem;
      height: 0.75rem;
      border-radius: 50%;
      background-color: #9ca3af;
    }

    .connection-status .status-indicator.connected {
      background-color: #10b981;
    }

    .connection-status .status-indicator.disconnected {
      background-color: #ef4444;
    }

    /* Feedback items */
    .feedback-items {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .feedback-item {
      position: relative;
      border-radius: 0.5rem;
      background-color: #1f2937;
      overflow: hidden;
      animation: fadeIn 0.3s ease-out;
      transition: all 0.3s ease;
    }

    .feedback-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      border-bottom: 1px solid #374151;
    }

    .feedback-metadata {
      display: flex;
      flex-direction: column;
    }

    .user-info {
      font-size: 0.875rem;
      font-weight: 500;
      color: #f3f4f6;
    }

    .date-info {
      font-size: 0.75rem;
      color: #9ca3af;
    }

    .feedback-actions {
      display: flex;
      gap: 0.5rem;
    }

    .action-btn {
      padding: 0.375rem;
      border-radius: 9999px;
      background-color: transparent;
      border: none;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .action-btn:hover {
      background-color: #374151;
    }

    .action-btn.positive {
      color: #10b981;
    }

    .action-btn.positive.active {
      background-color: rgba(16, 185, 129, 0.2);
    }

    .action-btn.negative {
      color: #ef4444;
    }

    .action-btn.negative.active {
      background-color: rgba(239, 68, 68, 0.2);
    }

    .action-btn.hidden {
      color: #9ca3af;
    }

    .action-btn.hidden.active {
      background-color: rgba(124, 58, 237, 0.2);
      color: #a78bfa;
    }

    /* Schema Selection */
    .schema-selection {
      display: flex;
      gap: 0.5rem;
      margin: 0.5rem 1rem;
    }

    .schema-btn {
      padding: 0.25rem 0.75rem;
      border-radius: 0.25rem;
      font-size: 0.875rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: 1px solid #374151;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .schema-btn:hover {
      background-color: #2d3748;
    }

    .schema-btn.active {
      background-color: #2563eb;
      color: white;
      border-color: #2563eb;
    }

    /* Tab Styles */
    .feedback-header {
      display: flex;
      align-items: center;
      background-color: #1f2937;
      border-bottom: 1px solid #374151;
    }

    .tab-btn {
      flex: 1;
      padding: 1rem;
      background-color: #1f2937;
      color: #f3f4f6;
      border: none;
      text-align: center;
      font-size: 1rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .tab-btn:hover {
      background-color: #374151;
    }

    .tab-btn.active {
      background-color: #2563eb;
      color: white;
    }

    .feedback-content {
      background-color: #1f2937;
      padding: 1rem;
      min-height: 200px;
      overflow-y: auto;
      max-height: calc(100vh - 300px);
    }

    /* Tab Content Styles */
    .tab-content {
      display: none;
      padding: 1rem;
    }

    .tab-content.active {
      display: block;
    }

    /* Conversation Tab */
    .conversation-item {
      margin-bottom: 1rem;
    }

    .conversation-item.user {
      text-align: right;
    }

    .conversation-item.assistant {
      text-align: left;
    }

    .conversation-bubble {
      display: inline-block;
      max-width: 80%;
      padding: 0.75rem;
      border-radius: 0.5rem;
      white-space: pre-line;
    }

    .conversation-item.user .conversation-bubble {
      background-color: #2563eb;
      color: white;
      border-top-right-radius: 0;
    }

    .conversation-item.assistant .conversation-bubble {
      background-color: #374151;
      color: white;
      border-top-left-radius: 0;
    }

    .conversation-role {
      font-size: 0.875rem;
      font-weight: 500;
      margin-bottom: 0.25rem;
      opacity: 0.7;
    }

    /* Suggestion and Cypher Query Tabs */
    .suggestion-list, .cypher-list {
      list-style-type: none;
      padding-left: 0;
    }

    .suggestion-list li, .cypher-list li {
      padding: 0.75rem;
      background-color: #374151;
      border-radius: 0.5rem;
      margin-bottom: 0.75rem;
      word-wrap: break-word;
      white-space: pre-wrap;
    }

    /* Tabs Navigation */
    .tabs-container {
      margin-bottom: 1rem;
    }

    .tabs-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .tabs-list {
      display: flex;
      gap: 0.25rem;
      overflow-x: auto;
      scrollbar-width: thin;
      padding: 0.25rem 0;
      flex-grow: 1;
    }

    .tab-nav-btn {
      padding: 0.5rem 0.75rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: none;
      border-radius: 0.25rem;
      cursor: pointer;
      white-space: nowrap;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .tab-nav-btn:hover {
      background-color: #374151;
    }

    .tab-nav-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .pagination-btn {
      padding: 0.5rem 0.75rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: none;
      border-radius: 0.25rem;
      cursor: pointer;
    }

    .pagination-btn.active {
      background-color: #2563eb;
      color: white;
    }

    /* Animation overlay */
    .animation-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 0.5rem;
      background-color: rgba(0, 0, 0, 0.3);
      z-index: 20;
    }

    .animation-overlay.positive {
      background-color: rgba(16, 185, 129, 0.3);
    }

    .animation-overlay.negative {
      background-color: rgba(239, 68, 68, 0.3);
    }

    .animation-icon {
      width: 4rem;
      height: 4rem;
      animation: pulse 1s infinite;
    }

    .animation-icon.positive {
      color: #10b981;
    }

    .animation-icon.negative {
      color: #ef4444;
    }

    /* No results */
    .no-results {
      text-align: center;
      padding: 2.5rem 0;
      color: #9ca3af;
    }

    /* Animations and keyframes */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes pulse {
      0% { transform: scale(0.95); opacity: 0.8; }
      70% { transform: scale(1.1); opacity: 1; }
      100% { transform: scale(0.95); opacity: 0.8; }
    }

    .hidden {
      display: none;
    }

    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      color: #9ca3af;
    }

    .loading::before {
      content: "";
      width: 20px;
      height: 20px;
      margin-right: 10px;
      border-radius: 50%;
      border: 2px solid #9ca3af;
      border-top-color: #3b82f6;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Mürşit Feedback Sistemi</h1>

  <!-- MongoDB Connection Status -->
  <div class="connection-status">
    <div id="connection-indicator" class="status-indicator"></div>
    <span id="connection-text">Connecting to MongoDB...</span>
  </div>

  <!-- Search Bar -->
  <div class="search-container">
    <svg class="search-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="11" cy="11" r="8"></circle>
      <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
    </svg>
    <input type="text" id="search-input" class="search-input" placeholder="Search questions or queries...">
  </div>

  <!-- Schema Filter Buttons -->
  <div class="filter-section">
    <div class="filter-label">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
      </svg>
      <span>Şema Filtreleri:</span>
    </div>
    <div id="schema-filters" class="filter-buttons">
      <button data-schema="Mesai" class="filter-btn">Mesai</button>
      <button data-schema="Mukavele" class="filter-btn">Mukavele</button>
      <button data-schema="Genel" class="filter-btn">Genel</button>
    </div>
  </div>

  <!-- Feedback Filter Buttons -->
  <div class="feedback-filters">
    <div class="filter-label">
      <span>Feedback Filtreleri:</span>
    </div>
    <button id="positive-filter" class="filter-btn">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
        <path d="M7 10v12"></path>
        <path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z"></path>
      </svg>
      Positive
    </button>
    <button id="negative-filter" class="filter-btn">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
        <path d="M17 14V2"></path>
        <path d="M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22h0a3.13 3.13 0 0 1-3-3.88Z"></path>
      </svg>
      Negative
    </button>
    <button id="hidden-filter" class="filter-btn">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
        <rect width="20" height="5" x="2" y="3" rx="1"></rect>
        <path d="M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8"></path>
        <path d="M10 12h4"></path>
      </svg>
      Show Archived
    </button>
  </div>

  <!-- Page Size Selection -->
  <div class="page-size">
    <span>Gösterilecek:</span>
    <button data-size="20" class="page-size-btn active">20</button>
    <button data-size="40" class="page-size-btn">40</button>
    <button data-size="100" class="page-size-btn">100</button>
    <button data-size="200" class="page-size-btn">200</button>
  </div>

  <!-- Tabs Navigation -->
  <div id="tabs-container" class="tabs-container">
    <div class="tabs-header">
      <button id="prev-tab-btn" class="tab-nav-btn">&laquo; Previous</button>
      <div id="tabs-list" class="tabs-list"></div>
      <button id="next-tab-btn" class="tab-nav-btn">Next &raquo;</button>
    </div>
  </div>

  <!-- Results count -->
  <div id="results-count" class="results-count"></div>

  <!-- Feedback Items -->
  <div id="feedback-items" class="feedback-items"></div>

  <!-- No results message -->
  <div id="no-results" class="no-results hidden">
    No questions found matching your criteria
  </div>
</div>

<!-- Feedback Item Template -->
<template id="feedback-item-template">
  <div class="feedback-item">
    <div class="feedback-item-header">
      <div class="feedback-metadata">
        <div class="user-info">User: <span class="user-name">username</span></div>
        <div class="date-info"><span class="datetime">YYYY-MM-DD HH:MM</span></div>
      </div>
      <div class="feedback-actions">
        <button class="action-btn positive" data-action="positive" title="Positive Feedback">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M7 10v12"></path>
            <path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z"></path>
          </svg>
        </button>
        <button class="action-btn negative" data-action="negative" title="Negative Feedback">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M17 14V2"></path>
            <path d="M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22h0a3.13 3.13 0 0 1-3-3.88Z"></path>
          </svg>
        </button>
        <button class="action-btn hidden" data-action="hidden" title="Archive">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect width="20" height="5" x="2" y="3" rx="1"></rect>
            <path d="M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8"></path>
            <path d="M10 12h4"></path>
          </svg>
        </button>
      </div>
    </div>
    <!-- Schema Selection -->
    <div class="schema-selection">
      <button class="schema-btn" data-schema="Mesai">Mesai</button>
      <button class="schema-btn" data-schema="Mukavele">Mukavele</button>
      <button class="schema-btn" data-schema="Genel">Genel</button>
    </div>
    <div class="feedback-header">
      <button class="tab-btn conversation-tab active" data-tab="conversation">Conversation</button>
      <button class="tab-btn suggestion-tab" data-tab="suggestion">Suggestion</button>
      <button class="tab-btn cypher-tab" data-tab="cypher">Cypher Query</button>
    </div>
    <div class="feedback-content">
      <div class="tab-content conversation-content active" data-tab-content="conversation"></div>
      <div class="tab-content suggestion-content" data-tab-content="suggestion">
        <ul class="suggestion-list"></ul>
      </div>
      <div class="tab-content cypher-content" data-tab-content="cypher">
        <ul class="cypher-list"></ul>
      </div>
    </div>
  </div>
</template>

<script>
  // MongoDB API config
  const API_BASE_URL = "http://localhost:3000/api"; // Change this to your deployed API URL in production

  // App state
  let data = [];
  let filteredData = [];
  let activeSchema = null;
  let activeFeedbackFilter = null;
  let showHidden = false;
  let pageSize = 20;
  let searchQuery = '';
  let activeAnimationId = null;
  let animationTimeout = null;
  let currentItemId = null;
  let schemaList = ["Mesai", "Mukavele", "Genel"];
  let currentPage = 0;
  let totalPages = 0;
  let visibleTabCount = 5; // Number of tabs to show at once

  // Load or initialize DOM elements
  document.addEventListener('DOMContentLoaded', function() {
    // Query for DOM elements
    const searchInput = document.getElementById('search-input');
    const schemaFilterButtons = document.querySelectorAll('#schema-filters .filter-btn');
    const positiveFilter = document.getElementById('positive-filter');
    const negativeFilter = document.getElementById('negative-filter');
    const hiddenFilter = document.getElementById('hidden-filter');
    const pageSizeButtons = document.querySelectorAll('.page-size-btn');
    const resultsCount = document.getElementById('results-count');
    const feedbackItems = document.getElementById('feedback-items');
    const noResults = document.getElementById('no-results');
    const connectionIndicator = document.getElementById('connection-indicator');
    const connectionText = document.getElementById('connection-text');

    // Setup event listeners
    searchInput.addEventListener('input', () => {
      searchQuery = searchInput.value.toLowerCase();
      applyFilters();
    });

    // Schema filter buttons (for filtering)
    schemaFilterButtons.forEach(button => {
      const schema = button.dataset.schema;
      button.addEventListener('click', () => filterBySchema(schema));
    });

    // Feedback filter event listeners
    positiveFilter.addEventListener('click', () => {
      if (activeFeedbackFilter === 'positive') {
        activeFeedbackFilter = null;
        positiveFilter.classList.remove('active');
      } else {
        activeFeedbackFilter = 'positive';
        positiveFilter.classList.add('active');
        negativeFilter.classList.remove('active');
      }
      applyFilters();
    });

    negativeFilter.addEventListener('click', () => {
      if (activeFeedbackFilter === 'negative') {
        activeFeedbackFilter = null;
        negativeFilter.classList.remove('active');
      } else {
        activeFeedbackFilter = 'negative';
        negativeFilter.classList.add('active');
        positiveFilter.classList.remove('active');
      }
      applyFilters();
    });

    // Toggle hidden items
    hiddenFilter.addEventListener('click', () => {
      showHidden = !showHidden;
      if (showHidden) {
        hiddenFilter.classList.add('active');
        hiddenFilter.textContent = 'Hide Archived';
        hiddenFilter.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
            <rect width="20" height="5" x="2" y="3" rx="1"></rect>
            <path d="M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8"></path>
            <path d="M10 12h4"></path>
          </svg>
          Hide Archived
        `;
      } else {
        hiddenFilter.classList.remove('active');
        hiddenFilter.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
            <rect width="20" height="5" x="2" y="3" rx="1"></rect>
            <path d="M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8"></path>
            <path d="M10 12h4"></path>
          </svg>
          Show Archived
        `;
      }
      applyFilters();
    });

    // Page size buttons
    pageSizeButtons.forEach(button => {
      button.addEventListener('click', () => {
        pageSizeButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        pageSize = parseInt(button.dataset.size);
        renderItems();
      });
    });

    // Initialize with MongoDB connection
    connectToMongoDB();
  });

  // Updated MongoDB data conversion focusing on required fields
  function convertMongoDataToAppFormat(mongoData) {
    if (!mongoData || !Array.isArray(mongoData)) {
      console.error("Invalid MongoDB data:", mongoData);
      return [];
    }

    try {
      return mongoData.map(item => {
        try {
          // Handle various message formats
          let parsedMessages;
          if (typeof item.messages === 'string') {
            parsedMessages = parseMessages(item.messages);
          } else if (Array.isArray(item.messages)) {
            parsedMessages = parseMessages(item.messages);
          } else {
            parsedMessages = [
              { role: 'user', message: 'No messages available' }
            ];
          }

          // Find the first user message for title
          const firstUserMessage = parsedMessages.find(msg => msg.role === 'user');

          // Extract suggestions if available (can be in different formats)
          let suggestions = [];
          if (item.suggest && typeof item.suggest === 'string') {
            // Try to parse if it's a JSON string
            try {
              suggestions = JSON.parse(item.suggest);
            } catch {
              // If not JSON, split by newlines or use as is
              suggestions = item.suggest.includes('\n') ? 
                item.suggest.split('\n').filter(Boolean) : 
                [item.suggest];
            }
          } else if (Array.isArray(item.suggest)) {
            suggestions = item.suggest;
          }

          // Extract cypher queries
          let cypherQueries = [];
          if (item.cypher && typeof item.cypher === 'string') {
            // Try to parse if it's a JSON string
            try {
              cypherQueries = JSON.parse(item.cypher);
            } catch {
              // If not JSON, split by newlines or use as is
              cypherQueries = item.cypher.includes('\n') ? 
                item.cypher.split('\n').filter(Boolean) : 
                [item.cypher];
            }
          } else if (Array.isArray(item.cypher)) {
            cypherQueries = item.cypher;
          }

          // Handle different MongoDB ID formats
          const id = item._id?.$oid || item._id || item.id;

          // Format the timestamp as a readable date
          let formattedDate = 'Unknown date';
          if (item.timestamp) {
            // Convert timestamp to Date object
            const date = new Date(
              typeof item.timestamp === 'number' ? 
                item.timestamp * 1000 : // convert to milliseconds if it's a Unix timestamp
                item.timestamp
            );
            formattedDate = isNaN(date) ? 'Invalid date' : 
              date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
          } else if (item.RDate && item.RDate.$date) {
            // Handle MongoDB Date format
            const date = new Date(
              typeof item.RDate.$date === 'object' && item.RDate.$date.$numberLong ? 
                parseInt(item.RDate.$date.$numberLong) : 
                item.RDate.$date
            );
            formattedDate = isNaN(date) ? 'Invalid date' : 
              date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
          }

          return {
            id: id || `temp-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
            schema: item.schema || '',
            question: firstUserMessage ? firstUserMessage.message : 'No question found',
            conversation: parsedMessages,
            suggestions: suggestions,
            cypherQueries: cypherQueries,
            feedback: item.feedback || null,
            hidden: item.hidden || false,
            user: item.userName || 'Unknown',
            datetime: formattedDate,
            timestamp: item.timestamp || ''
          };
        } catch (itemError) {
          console.error("Error converting item:", itemError, item);
          return null;
        }
      }).filter(Boolean); // Remove any null items from errors
    } catch (error) {
      console.error("Error converting MongoDB data:", error);
      return [];
    }
  }

  // Memory-efficient message parsing
  function parseMessages(messagesString) {
    // Handle non-string input
    if (typeof messagesString !== 'string') {
      // If it's already an object/array, process it directly
      if (typeof messagesString === 'object' && messagesString !== null) {
        if (Array.isArray(messagesString)) {
          return messagesString.map(msg => ({
            role: msg.role || 'unknown',
            message: typeof msg.content === 'object' ?
                    JSON.stringify(msg.content) :
                    msg.content || 'No content'
          }));
        }

        // If single object, convert to array
        return [{
          role: messagesString.role || 'unknown',
          message: typeof messagesString.content === 'object' ?
                  JSON.stringify(messagesString.content) :
                  messagesString.content || 'No content'
        }];
      }

      // Return default for non-string non-object
      console.warn('Messages is not a string or object:', messagesString);
      return [
        { role: 'user', message: 'Message parsing error' },
        { role: 'assistant', message: 'Unable to parse messages' }
      ];
    }

    try {
      // Clean the string to make it more JSON-like
      let cleanedString = messagesString
              .replace(/([a-zA-Z]+)=/g, '"$1":')  // Convert property=value to "property":value
              .replace(/'/g, '"')                  // Replace single quotes with double quotes
              .replace(/\"\{/g, '{')              // Fix any malformed quotes before brackets
              .replace(/\}\"/g, '}');             // Fix any malformed quotes after brackets

      // Try to parse as JSON
      try {
        const parsed = JSON.parse(cleanedString);
        if (Array.isArray(parsed)) {
          return parsed.map(msg => ({
            role: msg.role || 'unknown',
            message: typeof msg.content === 'object' ?
                    (msg.content.reduced_user_message || JSON.stringify(msg.content)) :
                    msg.content || 'No content'
          }));
        }
      } catch (jsonError) {
        // Continue to regex approach if JSON parsing fails
      }

      // Use regex to extract content - covers most common formats
      const regex = /\{(?:['"]?role['"]?[:=]\s*['"]?(.*?)['"]?[,}]).*?(?:['"]?content['"]?[:=]\s*(.*?)(?=\s*[,}]|$))/g;
      const matches = [];
      let match;

      while ((match = regex.exec(messagesString)) !== null) {
        const role = match[1]?.trim() || 'unknown';
        let content = match[2];

        // Clean up content
        if (content) {
          // Remove surrounding quotes if present
          content = content.replace(/^['"]|['"]$/g, '');

          // Handle object content - simplified approach
          if (content.startsWith('{') && content.endsWith('}')) {
            try {
              const contentObj = JSON.parse(content.replace(/'/g, '"'));
              content = contentObj.reduced_user_message || JSON.stringify(contentObj);
            } catch (e) {
              // Keep as is if parsing fails
            }
          }
        }

        matches.push({
          role: role,
          message: content || 'No content'
        });
      }

      if (matches.length > 0) {
        return matches;
      }

      // Last resort simple format detection
      if (messagesString.includes('role') && messagesString.includes('content')) {
        const items = messagesString.split('},').map(part => part.trim() + (part.endsWith('}') ? '' : '}'));

        return items.map(item => {
          const roleMatch = item.match(/role['":\s=]+(['"]?)(.*?)\1[,}]/i);
          const contentMatch = item.match(/content['":\s=]+(['"]?)(.*?)\1[,}]/i);

          return {
            role: roleMatch ? roleMatch[2].trim() : 'unknown',
            message: contentMatch ? contentMatch[2].trim() : 'No content'
          };
        });
      }

      // Return default for unparseable content
      return [
        { role: 'user', message: 'Error parsing message content' }
      ];
    } catch (error) {
      console.error("Critical error parsing messages:", error);
      return [
        { role: 'user', message: 'Error parsing message' }
      ];
    }
  }

  // Connect to MongoDB via API with pagination
  async function connectToMongoDB(page = 0) {
    try {
      // Show connecting status
      connectionIndicator.classList.remove('connected');
      connectionIndicator.classList.remove('disconnected');
      connectionText.textContent = `Connecting to MongoDB (page ${page + 1})...`;

      // Clear existing data
      data = [];
      filteredData = [];

      // Fetch data from our backend API with pagination
      const response = await fetch(`${API_BASE_URL}/conversations?page=${page}&limit=${pageSize}`);

      if (!response.ok) {
        throw new Error(`API responded with status: ${response.status}`);
      }

      const result = await response.json();
      console.log("API response:", result);

      let mongoData;
      if (result.data) {
        mongoData = result.data;

        // Update pagination info
        currentPage = result.pagination.page;
        totalPages = result.pagination.totalPages;
      } else {
        // Handle old API format
        mongoData = result;
        currentPage = 0;
        totalPages = 1;
      }

      // Update connection status
      connectionIndicator.classList.add('connected');
      connectionText.textContent = `Connected to MongoDB - ${mongoData.length} records loaded`;

      if (result.pagination) {
        connectionText.textContent += ` (Page ${currentPage + 1} of ${totalPages} - Total: ${result.pagination.totalCount})`;
      }

      // Convert and store data
      data = convertMongoDataToAppFormat(mongoData);
      console.log("Converted data:", data);

      filteredData = [...data.filter(item => !item.hidden)];

      // Initialize tabs
      initializeTabs(totalPages);

      // Render items
      renderItems();

    } catch (error) {
      console.error('Error connecting to MongoDB:', error);
      connectionIndicator.classList.add('disconnected');
      connectionText.textContent = 'Failed to connect to MongoDB: ' + error.message;

      // For development/testing - use sample data in case of error
      if (confirm('Connection to API failed. Use sample data instead?')) {
        // Create some sample data
        const sampleData = [
          {
            id: "sample1",
            schema: "Mesai",
            question: "What are my work hours this week?",
            conversation: [
              { role: "user", message: "What are my work hours this week?" },
              { role: "assistant", message: "Your work hours for this week are:\nMonday: 9 AM - 5 PM\nTuesday: 9 AM - 5 PM\nWednesday: 10 AM - 6 PM\nThursday: 9 AM - 5 PM\nFriday: 9 AM - 4 PM" }
            ],
            suggestions: [
              "You might want to check your overtime hours for last week",
              "Would you like to request time off?",
              "Do you need to see your vacation balance?"
            ],
            cypherQueries: [
              "MATCH (e:Employee {id: '12345'})-[:HAS_SCHEDULE]->(s:Schedule) WHERE s.week = '2023-W42' RETURN s",
              "MATCH (e:Employee {id: '12345'})-[:WORKED]->(h:Hours) WHERE h.date >= '2023-10-16' RETURN h"
            ],
            feedback: "positive",
            hidden: false,
            user: "testuser1",
            datetime: "2023-10-20 14:32:45"
          },
          {
            id: "sample2",
            schema: "Mukavele",
            question: "When does my contract expire?",
            conversation: [
              { role: "user", message: "When does my contract expire?" },
              { role: "assistant", message: "Your current contract expires on December 31, 2023. Would you like information about the renewal process?" }
            ],
            suggestions: [
              "You might want to review your contract terms",
              "Would you like to schedule a meeting with HR about renewal?",
              "Do you need information about contract extensions?"
            ],
            cypherQueries: [
              "MATCH (e:Employee {id: '12345'})-[:HAS_CONTRACT]->(c:Contract) RETURN c.expiryDate",
              "MATCH (c:Contract)-[:HAS_TERMS]->(t:Terms) WHERE c.employeeId = '12345' RETURN t"
            ],
            feedback: "negative",
            hidden: false,
            user: "testuser2",
            datetime: "2023-10-19 10:15:30"
          },
          {
            id: "sample3",
            schema: "Genel",
            question: "How do I request vacation time?",
            conversation: [
              { role: "user", message: "How do I request vacation time?" },
              { role: "assistant", message: "To request vacation time, you need to:\n1. Log into the employee portal\n2. Go to 'Time Off' section\n3. Click 'Request Time Off'\n4. Select the dates and type of leave\n5. Submit for approval" }
            ],
            suggestions: [
              "You currently have 15 vacation days available",
              "Would you like to see the company holiday calendar?",
              "Do you need information about sick leave policy?"
            ],
            cypherQueries: [
              "MATCH (e:Employee {id: '12345'})-[:HAS_BENEFITS]->(b:Benefits) RETURN b.vacationDays",
              "MATCH (p:Policy {type: 'vacation'})-[:APPLIES_TO]->(d:Department {id: '54321'}) RETURN p"
            ],
            feedback: null,
            hidden: true,
            user: "testuser3",
            datetime: "2023-10-18 09:45:12"
          }
        ];

        data = sampleData;
        filteredData = [...data.filter(item => !item.hidden)];

        // Mock pagination for sample data
        currentPage = 0;
        totalPages = 1;
        initializeTabs(totalPages);

        renderItems();
      }
    }
  }

  // Initialize tab navigation
  function initializeTabs(totalPages) {
    const tabsList = document.getElementById('tabs-list');
    const prevTabBtn = document.getElementById('prev-tab-btn');
    const nextTabBtn = document.getElementById('next-tab-btn');

    if (!tabsList || !prevTabBtn || !nextTabBtn) return;

    // Clear existing tabs
    tabsList.innerHTML = '';

    // Create tabs
    for (let i = 0; i < totalPages; i++) {
      const tab = document.createElement('button');
      tab.className = `pagination-btn${currentPage === i ? ' active' : ''}`;
      tab.textContent = `Page ${i + 1}`;
      tab.dataset.page = i;

      tab.addEventListener('click', () => {
        if (currentPage !== i) {
          loadPage(i);
        }
      });

      tabsList.appendChild(tab);
    }

    // Update tab visibility based on current page
    updateTabsVisibility();

    // Update navigation buttons
    prevTabBtn.disabled = currentPage === 0;
    nextTabBtn.disabled = currentPage === totalPages - 1;

    // Add event listeners to navigation buttons
    prevTabBtn.addEventListener('click', () => {
      if (currentPage > 0) {
        loadPage(currentPage - 1);
      }
    });

    nextTabBtn.addEventListener('click', () => {
      if (currentPage < totalPages - 1) {
        loadPage(currentPage + 1);
      }
    });
  }

  // Load specific page
  async function loadPage(page) {
    // Show loading state
    connectionText.textContent = `Loading page ${page + 1}...`;

    try {
      // Fetch data for specific page
      const response = await fetch(`${API_BASE_URL}/conversations?page=${page}&limit=${pageSize}`);

      if (!response.ok) {
        throw new Error(`API responded with status: ${response.status}`);
      }

      const result = await response.json();
      const mongoData = result.data;

      // Update current page
      currentPage = page;

      // Convert and store data
      data = convertMongoDataToAppFormat(mongoData);
      filteredData = [...data.filter(item => !item.hidden)];

      // Update tabs
      const tabButtons = document.querySelectorAll('.pagination-btn');
      tabButtons.forEach(tab => {
        const tabPage = parseInt(tab.dataset.page);
        tab.classList.toggle('active', tabPage === currentPage);
      });

      // Update tab visibility
      updateTabsVisibility();

      // Update navigation buttons
      document.getElementById('prev-tab-btn').disabled = currentPage === 0;
      document.getElementById('next-tab-btn').disabled = currentPage === totalPages - 1;

      // Update connection status
      connectionText.textContent = `Page ${currentPage + 1} of ${totalPages} - Total records: ${result.pagination.totalCount}`;

      // Render items
      renderItems();

    } catch (error) {
      console.error('Error loading page:', error);
      connectionText.textContent = `Failed to load page ${page + 1}: ${error.message}`;
    }
  }

  // Update which tabs are visible
  function updateTabsVisibility() {
    const tabButtons = document.querySelectorAll('.pagination-btn');

    // Calculate start and end indexes for visible tabs
    let startIndex = Math.max(0, currentPage - Math.floor(visibleTabCount / 2));
    let endIndex = Math.min(totalPages - 1, startIndex + visibleTabCount - 1);

    // Adjust start index if needed
    if (endIndex - startIndex + 1 < visibleTabCount) {
      startIndex = Math.max(0, endIndex - visibleTabCount + 1);
    }

    // Show/hide tabs based on calculated range
    tabButtons.forEach((tab, index) => {
      tab.style.display = (index >= startIndex && index <= endIndex) ? 'block' : 'none';
    });
  }

  // Filter by schema
  function filterBySchema(schema) {
    const button = document.querySelector(`.filter-btn[data-schema="${schema}"]`);

    if (!button) return;

    if (activeSchema === schema) {
      activeSchema = null;
      button.classList.remove('active');
    } else {
      // Remove active class from all schema buttons
      document.querySelectorAll('.filter-btn[data-schema]').forEach(btn => {
        btn.classList.remove('active');
      });

      activeSchema = schema;
      button.classList.add('active');
    }

    applyFilters();
  }

  // Apply all filters
  function applyFilters() {
    let filtered = [...data];

    // Apply schema filter if active
    if (activeSchema) {
      filtered = filtered.filter(item => item.schema === activeSchema);
    }

    // Apply feedback filter if active
    if (activeFeedbackFilter) {
      filtered = filtered.filter(item => item.feedback === activeFeedbackFilter);
    }

    // Apply hidden filter
    if (!showHidden) {
      filtered = filtered.filter(item => !item.hidden);
    }

    // Apply search query
    if (searchQuery) {
      filtered = filtered.filter(item =>
        (item.question && item.question.toLowerCase().includes(searchQuery)) ||
        (item.conversation && item.conversation.some(msg => 
          msg.message.toLowerCase().includes(searchQuery)
        )) ||
        (item.user && item.user.toLowerCase().includes(searchQuery))
      );
    }

    filteredData = filtered;
    renderItems();
  }

  // Render feedback items
  function renderItems() {
    const feedbackItems = document.getElementById('feedback-items');
    const noResults = document.getElementById('no-results');
    const resultsCount = document.getElementById('results-count');
    
    if (!feedbackItems || !noResults || !resultsCount) return;

    // Update results count
    resultsCount.textContent = `Showing ${Math.min(pageSize, filteredData.length)} of ${filteredData.length} results`;

    // Clear items container
    feedbackItems.innerHTML = '';

    // Show or hide no results message
    if (filteredData.length === 0) {
      noResults.classList.remove('hidden');
    } else {
      noResults.classList.add('hidden');

      // Get template
      const template = document.getElementById('feedback-item-template');
      
      // Render items
      filteredData.slice(0, pageSize).forEach((item, index) => {
        // Clone template
        const itemElement = template.content.cloneNode(true).children[0];
        
        // Set data attributes
        itemElement.dataset.id = item.id;
        if (item.hidden) itemElement.classList.add('hidden');
        if (item.feedback === 'positive') {
          itemElement.querySelector('.action-btn.positive').classList.add('active');
        } else if (item.feedback === 'negative') {
          itemElement.querySelector('.action-btn.negative').classList.add('active');
        }
        if (item.hidden) {
          itemElement.querySelector('.action-btn.hidden').classList.add('active');
        }

        // Set user and date info
        itemElement.querySelector('.user-name').textContent = item.user || 'Unknown';
        itemElement.querySelector('.datetime').textContent = item.datetime || 'Unknown date';

        // Set schema buttons
        const schemaButtons = itemElement.querySelectorAll('.schema-btn');
        schemaButtons.forEach(button => {
          const buttonSchema = button.dataset.schema;
          button.classList.toggle('active', buttonSchema === item.schema);
          
          // Add click event for assigning schema
          button.addEventListener('click', () => {
            setSchema(item.id, buttonSchema);
          });
        });

        // Set tab contents
        // 1. Conversation
        const conversationContent = itemElement.querySelector('.conversation-content');
        if (item.conversation && item.conversation.length > 0) {
          item.conversation.forEach(message => {
            const messageElement = document.createElement('div');
            messageElement.className = `conversation-item ${message.role}`;
            messageElement.innerHTML = `
              <div class="conversation-bubble">
                <p class="conversation-role">${message.role === 'user' ? 'User' : 'Assistant'}</p>
                <p>${message.message}</p>
              </div>
            `;
            conversationContent.appendChild(messageElement);
          });
        } else {
          conversationContent.innerHTML = '<p>No conversation available</p>';
        }

        // 2. Suggestions
        const suggestionList = itemElement.querySelector('.suggestion-list');
        if (item.suggestions && item.suggestions.length > 0) {
          item.suggestions.forEach(suggestion => {
            const li = document.createElement('li');
            li.textContent = suggestion;
            suggestionList.appendChild(li);
          });
        } else {
          suggestionList.innerHTML = '<li>No suggestions available</li>';
        }

        // 3. Cypher Queries
        const cypherList = itemElement.querySelector('.cypher-list');
        if (item.cypherQueries && item.cypherQueries.length > 0) {
          item.cypherQueries.forEach(query => {
            const li = document.createElement('li');
            li.textContent = query;
            cypherList.appendChild(li);
          });
        } else {
          cypherList.innerHTML = '<li>No Cypher queries available</li>';
        }

        // Add event listeners for tabs
        const tabButtons = itemElement.querySelectorAll('.tab-btn');
        tabButtons.forEach(button => {
          button.addEventListener('click', () => {
            const tabName = button.dataset.tab;
            
            // Remove active class from all tab buttons
            itemElement.querySelectorAll('.tab-btn').forEach(btn => {
              btn.classList.remove('active');
            });
            
            // Hide all tab contents
            itemElement.querySelectorAll('.tab-content').forEach(content => {
              content.classList.remove('active');
            });
            
            // Add active class to clicked button
            button.classList.add('active');
            
            // Show corresponding tab content
            itemElement.querySelector(`.tab-content[data-tab-content="${tabName}"]`).classList.add('active');
          });
        });

        // Add event listeners for action buttons
        const actionButtons = itemElement.querySelectorAll('.action-btn');
        actionButtons.forEach(button => {
          button.addEventListener('click', e => {
            e.stopPropagation();
            const action = button.dataset.action;
            
            if (action === 'positive') {
              handlePositiveFeedback(item.id);
            } else if (action === 'negative') {
              handleNegativeFeedback(item.id);
            } else if (action === 'hidden') {
              handleToggleHidden(item.id);
            }
          });
        });

        // Add to container
        feedbackItems.appendChild(itemElement);
      });
    }
  }

  // Handle positive feedback
  async function handlePositiveFeedback(id) {
    const item = data.find(item => item.id === id);
    if (!item) return;

    // If already positive, remove feedback
    const newFeedback = item.feedback === 'positive' ? null : 'positive';

    // Update data locally first
    data = data.map(item => {
      if (item.id === id) {
        return { ...item, feedback: newFeedback };
      }
      return item;
    });

    // Update MongoDB via API
    try {
      const response = await fetch(`${API_BASE_URL}/conversations/${id}/feedback`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ feedback: newFeedback })
      });

      if (!response.ok) {
        console.error('Error updating feedback:', await response.text());
      }
    } catch (error) {
      console.error('Failed to update feedback:', error);
    }

    // Apply filters to update UI
    applyFilters();
  }

  // Handle negative feedback
  async function handleNegativeFeedback(id) {
    const item = data.find(item => item.id === id);
    if (!item) return;

    // If already negative, remove feedback
    const newFeedback = item.feedback === 'negative' ? null : 'negative';

    // Update data locally first
    data = data.map(item => {
      if (item.id === id) {
        return { ...item, feedback: newFeedback };
      }
      return item;
    });

    // Update MongoDB via API
    try {
      const response = await fetch(`${API_BASE_URL}/conversations/${id}/feedback`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ feedback: newFeedback })
      });

      if (!response.ok) {
        console.error('Error updating feedback:', await response.text());
      }
    } catch (error) {
      console.error('Failed to update feedback:', error);
    }

    // Apply filters to update UI
    applyFilters();
  }

  // Handle toggle hidden
  async function handleToggleHidden(id) {
    const item = data.find(item => item.id === id);
    if (!item) return;

    // Toggle hidden state
    const newHiddenState = !item.hidden;

    // Update data locally first
    data = data.map(item => {
      if (item.id === id) {
        return { ...item, hidden: newHiddenState };
      }
      return item;
    });

    // Update MongoDB via API
    try {
      const response = await fetch(`${API_BASE_URL}/conversations/${id}/archive`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ hidden: newHiddenState })
      });

      if (!response.ok) {
        console.error('Error updating archive status:', await response.text());
      }
    } catch (error) {
      console.error('Failed to update archive status:', error);
    }

    // Apply filters to update UI
    applyFilters();
  }

  // Set schema for an item
  async function setSchema(id, schema) {
    const item = data.find(item => item.id === id);
    if (!item) return;

    // Update schema locally first
    const oldSchema = item.schema;
    item.schema = schema;

    // Update schema buttons in this item
    const itemElement = document.querySelector(`.feedback-item[data-id="${id}"]`);
    if (itemElement) {
      const schemaButtons = itemElement.querySelectorAll('.schema-btn');
      schemaButtons.forEach(button => {
        const buttonSchema = button.dataset.schema;
        button.classList.toggle('active', buttonSchema === schema);
      });
    }

    // Update MongoDB via API
    try {
      const response = await fetch(`${API_BASE_URL}/conversations/${id}/schema`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ schema })
      });

      if (!response.ok) {
        console.error('Error updating schema:', await response.text());
        // Revert to old schema if update failed
        item.schema = oldSchema;
        if (itemElement) {
          const schemaButtons = itemElement.querySelectorAll('.schema-btn');
          schemaButtons.forEach(button => {
            const buttonSchema = button.dataset.schema;
            button.classList.toggle('active', buttonSchema === oldSchema);
          });
        }
        alert('Failed to update schema on server. Please try again.');
        return;
      }

      // Apply filters to update UI if needed
      if (activeSchema) {
        applyFilters();
      }
    } catch (error) {
      console.error('Failed to update schema:', error);
      // Revert to old schema if update failed
      item.schema = oldSchema;
      if (itemElement) {
        const schemaButtons = itemElement.querySelectorAll('.schema-btn');
        schemaButtons.forEach(button => {
          const buttonSchema = button.dataset.schema;
          button.classList.toggle('active', buttonSchema === oldSchema);
        });
      }
      alert('Failed to update schema: ' + error.message);
    }
  }
</script>

<!-- Include fix scripts -->
<script src="continuous-loading-fix.js"></script>
<script src="feedback-system-fixes.js"></script>
<script src="feedback-system-fixes-2.js"></script>
<script src="pagination-fix.js"></script>
<script src="similarity-fix.js"></script>
<script src="debug_mode.js"></script>
</html>
