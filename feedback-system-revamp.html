<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Chatbot Feedback System</title>
  <style>
    /* General styles */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background-color: #111827;
      color: #f3f4f6;
      line-height: 1.5;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
    }

    h1 {
      font-size: 1.5rem;
      font-weight: bold;
      margin-bottom: 1.5rem;
    }

    /* Search bar */
    .search-container {
      position: relative;
      margin-bottom: 1.5rem;
    }

    .search-icon {
      position: absolute;
      left: 0.75rem;
      top: 50%;
      transform: translateY(-50%);
      color: #9ca3af;
    }

    .search-input {
      width: 100%;
      padding: 0.625rem 0.75rem 0.625rem 2.5rem;
      background-color: #1f2937;
      border: 1px solid #374151;
      border-radius: 0.5rem;
      color: #f3f4f6;
      font-size: 0.875rem;
    }

    .search-input:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 1px #3b82f6;
    }

    /* Filter styles */
    .filter-section {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }

    .filter-label {
      display: flex;
      align-items: center;
      margin-right: 0.5rem;
    }

    .filter-label svg {
      margin-right: 0.25rem;
    }

    .filter-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .filter-btn {
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.875rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: none;
      cursor: pointer;
      transition: background-color 0.2s;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .filter-btn:hover {
      background-color: #374151;
    }

    .filter-btn.active {
      background-color: #2563eb;
      color: white;
    }

    /* Feedback filters */
    .feedback-filters {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      border-top: 1px solid #374151;
      padding-top: 1rem;
    }

    /* Page size buttons */
    .page-size {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      align-items: center;
    }

    .page-size-btn {
      padding: 0.25rem 0.75rem;
      border-radius: 0.25rem;
      font-size: 0.875rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: none;
      cursor: pointer;
    }

    .page-size-btn.active {
      background-color: #374151;
      color: white;
    }

    /* Results count */
    .results-count {
      margin-bottom: 1rem;
      color: #9ca3af;
      font-size: 0.875rem;
    }

    /* MongoDB Connection Styles */
    .connection-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
      font-size: 0.875rem;
    }

    .connection-status .status-indicator {
      width: 0.75rem;
      height: 0.75rem;
      border-radius: 50%;
      background-color: #9ca3af;
    }

    .connection-status .status-indicator.connected {
      background-color: #10b981;
    }

    .connection-status .status-indicator.disconnected {
      background-color: #ef4444;
    }

    /* Feedback items */
    .feedback-items {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .feedback-item {
      position: relative;
      display: flex;
      border-radius: 0.5rem;
      background-color: #1f2937;
      overflow: hidden;
      animation: fadeIn 0.3s ease-out;
      transition: all 0.3s ease;
    }

    /* Schema buttons on the left */
    .schema-buttons {
      display: flex;
      flex-direction: column;
      padding: 1rem;
      background-color: #1f2937;
      border-right: 1px solid #374151;
      min-width: 120px;
      justify-content: center;
      align-items: center;
      gap: 0.5rem;
    }

    .schema-btn {
      display: block;
      width: 100%;
      padding: 0.5rem;
      border-radius: 0.5rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: 1px solid #374151;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
    }

    .schema-btn:hover {
      background-color: #2d3748;
    }

    .schema-btn.active {
      background-color: #2563eb;
      color: white;
      border-color: #2563eb;
    }

    /* Content buttons in the middle */
    .feedback-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      padding: 1rem;
    }

    /* User info at top */
    .feedback-user-info {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: #9ca3af;
      border-bottom: 1px solid #374151;
      padding-bottom: 0.5rem;
    }

    .user-name {
      font-weight: 500;
    }

    .datetime {
      font-style: italic;
    }

    /* Conversation and action buttons */
    .feedback-buttons {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .conversation-btn {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      background-color: #374151;
      border: none;
      border-radius: 0.5rem;
      color: white;
      font-size: 1rem;
      text-align: left;
      cursor: pointer;
      transition: background-color 0.2s;
      min-height: 60px;
    }

    .conversation-btn:hover {
      background-color: #4b5563;
    }

    .small-buttons {
      display: flex;
      gap: 0.5rem;
      width: 100%;
    }

    .suggestion-btn, .cypher-btn {
      flex: 1;
      padding: 0.5rem;
      background-color: #374151;
      border: none;
      border-radius: 0.5rem;
      color: white;
      font-size: 0.875rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .suggestion-btn:hover, .cypher-btn:hover {
      background-color: #4b5563;
    }

    /* Feedback actions on the right */
    .feedback-actions {
      display: flex;
      flex-direction: column;
      padding: 1rem;
      background-color: #1f2937;
      border-left: 1px solid #374151;
      justify-content: center;
      gap: 1rem;
    }

    .action-btn {
      padding: 0.5rem;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
    }

    .action-btn:hover {
      transform: scale(1.1);
    }

    .action-btn svg {
      width: 20px;
      height: 20px;
    }

    .action-btn.positive {
      background-color: #10b981; /* Green */
      color: white;
    }

    .action-btn.positive:hover {
      background-color: #059669; /* Brighter green */
    }

    .action-btn.archive {
      background-color: #f59e0b; /* Yellow */
      color: white;
    }

    .action-btn.archive:hover {
      background-color: #d97706; /* Brighter yellow */
    }

    .action-btn.negative {
      background-color: #ef4444; /* Red */
      color: white;
    }

    .action-btn.negative:hover {
      background-color: #dc2626; /* Brighter red */
    }

    /* Modal styles for content popup */
    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    .modal-backdrop.active {
      opacity: 1;
      visibility: visible;
    }

    .modal-content {
      background-color: #1f2937;
      border-radius: 0.5rem;
      width: 90%;
      max-width: 900px;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      transform: scale(0.9);
      transition: transform 0.3s ease;
    }

    .modal-backdrop.active .modal-content {
      transform: scale(1);
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem;
      border-bottom: 1px solid #374151;
    }

    .modal-title {
      font-size: 1.2rem;
      font-weight: 500;
    }

    .modal-close {
      background: none;
      border: none;
      color: #9ca3af;
      cursor: pointer;
      padding: 0.5rem;
    }

    .modal-body {
      flex: 1;
      padding: 1rem;
      overflow-y: auto;
    }

    /* User info in modal */
    .user-info {
      display: flex;
      justify-content: space-between;
      padding: 0.5rem 0;
      font-size: 0.875rem;
      color: #9ca3af;
      margin-bottom: 0.5rem;
    }

    /* Conversation Tab */
    .conversation-item {
      margin-bottom: 1rem;
    }

    .conversation-item.user {
      text-align: right;
    }

    .conversation-item.assistant {
      text-align: left;
    }

    .conversation-bubble {
      display: inline-block;
      max-width: 80%;
      padding: 0.75rem;
      border-radius: 0.5rem;
      white-space: pre-line;
    }

    .conversation-item.user .conversation-bubble {
      background-color: #2563eb;
      color: white;
      border-top-right-radius: 0;
    }

    .conversation-item.assistant .conversation-bubble {
      background-color: #374151;
      color: white;
      border-top-left-radius: 0;
    }

    .conversation-role {
      font-size: 0.875rem;
      font-weight: 500;
      margin-bottom: 0.25rem;
      opacity: 0.7;
    }

    /* Suggestion and Cypher Query Tabs */
    .suggestion-list, .cypher-list {
      list-style-type: none;
      padding-left: 0;
    }

    .suggestion-list li, .cypher-list li {
      padding: 0.75rem;
      background-color: #374151;
      border-radius: 0.5rem;
      margin-bottom: 0.75rem;
      word-wrap: break-word;
      white-space: pre-wrap;
    }

    /* Tabs Navigation */
    .tabs-container {
      margin-bottom: 1rem;
    }

    .tabs-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .tabs-list {
      display: flex;
      gap: 0.25rem;
      overflow-x: auto;
      scrollbar-width: thin;
      padding: 0.25rem 0;
      flex-grow: 1;
    }

    .tab-nav-btn {
      padding: 0.5rem 0.75rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: none;
      border-radius: 0.25rem;
      cursor: pointer;
      white-space: nowrap;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .tab-nav-btn:hover {
      background-color: #374151;
    }

    .tab-nav-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .pagination-btn {
      padding: 0.5rem 0.75rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: none;
      border-radius: 0.25rem;
      cursor: pointer;
    }

    .pagination-btn.active {
      background-color: #2563eb;
      color: white;
    }

    /* No results */
    .no-results {
      text-align: center;
      padding: 2.5rem 0;
      color: #9ca3af;
    }
    /* Hide user info in modal */
    #modal-user-info {
      display: none;
    } 

    /* Animations and keyframes */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes pulse {
      0% { transform: scale(0.95); opacity: 0.8; }
      70% { transform: scale(1.1); opacity: 1; }
      100% { transform: scale(0.95); opacity: 0.8; }
    }

    .hidden {
      display: none;
    }

    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      color: #9ca3af;
    }

    .loading::before {
      content: "";
      width: 20px;
      height: 20px;
      margin-right: 10px;
      border-radius: 50%;
      border: 2px solid #9ca3af;
      border-top-color: #3b82f6;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Mürşit Feedback Sistemi</h1>

  <!-- MongoDB Connection Status -->
  <div class="connection-status">
    <div id="connection-indicator" class="status-indicator"></div>
    <span id="connection-text">Connecting to MongoDB...</span>
  </div>

  <!-- Search Bar -->
  <div class="search-container">
    <svg class="search-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="11" cy="11" r="8"></circle>
      <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
    </svg>
    <input type="text" id="search-input" class="search-input" placeholder="Search questions or queries...">
  </div>

  <!-- Schema Filter Buttons -->
  <div class="filter-section">
    <div class="filter-label">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
      </svg>
      <span>Şema Filtreleri:</span>
    </div>
    <div id="schema-filters" class="filter-buttons">
      <button data-schema="Mesai" class="filter-btn">Mesai</button>
      <button data-schema="Mukavele" class="filter-btn">Mukavele</button>
      <button data-schema="Genel" class="filter-btn">Genel</button>
    </div>
  </div>

  <!-- Feedback Filter Buttons -->
  <div class="feedback-filters">
    <div class="filter-label">
      <span>Feedback Filtreleri:</span>
    </div>
    <button id="positive-filter" class="filter-btn">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
        <path d="M7 10v12"></path>
        <path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z"></path>
      </svg>
      Positive
    </button>
    <button id="negative-filter" class="filter-btn">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
        <path d="M17 14V2"></path>
        <path d="M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22h0a3.13 3.13 0 0 1-3-3.88Z"></path>
      </svg>
      Negative
    </button>
    <button id="hidden-filter" class="filter-btn">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
        <rect width="20" height="5" x="2" y="3" rx="1"></rect>
        <path d="M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8"></path>
        <path d="M10 12h4"></path>
      </svg>
      Show Archived
    </button>
  </div>

  <!-- Page Size Selection -->
  <div class="page-size">
    <span>Gösterilecek:</span>
    <button data-size="20" class="page-size-btn active">20</button>
    <button data-size="40" class="page-size-btn">40</button>
    <button data-size="100" class="page-size-btn">100</button>
    <button data-size="200" class="page-size-btn">200</button>
  </div>

  <!-- Tabs Navigation -->
  <div id="tabs-container" class="tabs-container">
    <div class="tabs-header">
      <button id="prev-tab-btn" class="tab-nav-btn">&laquo; Previous</button>
      <div id="tabs-list" class="tabs-list"></div>
      <button id="next-tab-btn" class="tab-nav-btn">Next &raquo;</button>
    </div>
  </div>

  <!-- Results count -->
  <div id="results-count" class="results-count"></div>

  <!-- Feedback Items -->
  <div id="feedback-items" class="feedback-items"></div>

  <!-- No results message -->
  <div id="no-results" class="no-results hidden">
    No questions found matching your criteria
  </div>
</div>

<!-- Modal for viewing feedback content -->
<div id="feedback-modal" class="modal-backdrop">
  <div class="modal-content">
    <div class="modal-header">
      <div class="modal-title" id="modal-title">Feedback Details</div>
      <button class="modal-close" id="modal-close">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
    </div>
    <div class="user-info" id="modal-user-info">
      <span id="modal-username">User: username</span>
      <span id="modal-datetime">Date: YYYY-MM-DD HH:MM</span>
    </div>
    <div class="modal-body" id="modal-body">
      <!-- Content will be dynamically inserted here -->
    </div>
  </div>
</div>

<script>
  // MongoDB API config
  const API_BASE_URL = "http://localhost:3000/api"; // Change this to your deployed API URL in production

  // App state
  let data = [];
  let filteredData = [];
  let activeSchema = null;
  let activeFeedbackFilter = null;
  let showHidden = false;
  let pageSize = 20;
  let searchQuery = '';
  let activeAnimationId = null;
  let animationTimeout = null;
  let currentItemId = null;
  let schemaList = ["Mesai", "Mukavele", "Genel"];
  let currentPage = 0;
  let totalPages = 0;
  let visibleTabCount = 5; // Number of tabs to show at once

  // Function to format date in a user-friendly way
  function formatDateTime(dateStr) {
    // If it's already a well-formatted date, return it
    if (/\d{1,2}\/\d{1,2}\/\d{4}, \d{1,2}:\d{2}:\d{2}/.test(dateStr)) {
      return dateStr;
    }

    let date;

    // Try to parse the date string
    if (typeof dateStr === 'string') {
      // Handle ISO format
      if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(dateStr)) {
        date = new Date(dateStr);
      }
      // Handle Unix timestamp (seconds)
      else if (/^\d{10}$/.test(dateStr)) {
        date = new Date(parseInt(dateStr) * 1000);
      }
      // Handle Unix timestamp (milliseconds)
      else if (/^\d{13}$/.test(dateStr)) {
        date = new Date(parseInt(dateStr));
      }
      // Try general parsing as a fallback
      else {
        date = new Date(dateStr);
      }
    } else if (dateStr instanceof Date) {
      date = dateStr;
    } else {
      return "Invalid date";
    }

    // Check if the date is valid
    if (isNaN(date.getTime())) {
      return "Invalid date";
    }

    // Format the date in a user-friendly way
    const options = {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    };

    return date.toLocaleDateString(undefined, options);
  }

  // Load or initialize DOM elements
  document.addEventListener('DOMContentLoaded', function() {
    // Query for DOM elements
    const searchInput = document.getElementById('search-input');
    const schemaFilterButtons = document.querySelectorAll('#schema-filters .filter-btn');
    const positiveFilter = document.getElementById('positive-filter');
    const negativeFilter = document.getElementById('negative-filter');
    const hiddenFilter = document.getElementById('hidden-filter');
    const pageSizeButtons = document.querySelectorAll('.page-size-btn');
    const resultsCount = document.getElementById('results-count');
    const feedbackItems = document.getElementById('feedback-items');
    const noResults = document.getElementById('no-results');
    const connectionIndicator = document.getElementById('connection-indicator');
    const connectionText = document.getElementById('connection-text');

    // Modal elements
    const modal = document.getElementById('feedback-modal');
    const modalClose = document.getElementById('modal-close');

    // Setup event listeners
    searchInput.addEventListener('input', () => {
      searchQuery = searchInput.value.toLowerCase();
      applyFilters();
    });

    // Schema filter buttons (for filtering)
    schemaFilterButtons.forEach(button => {
      const schema = button.dataset.schema;
      button.addEventListener('click', () => filterBySchema(schema));
    });

    // Feedback filter event listeners
    positiveFilter.addEventListener('click', () => {
      if (activeFeedbackFilter === 'positive') {
        activeFeedbackFilter = null;
        positiveFilter.classList.remove('active');
      } else {
        activeFeedbackFilter = 'positive';
        positiveFilter.classList.add('active');
        negativeFilter.classList.remove('active');
      }
      applyFilters();
    });

    negativeFilter.addEventListener('click', () => {
      if (activeFeedbackFilter === 'negative') {
        activeFeedbackFilter = null;
        negativeFilter.classList.remove('active');
      } else {
        activeFeedbackFilter = 'negative';
        negativeFilter.classList.add('active');
        positiveFilter.classList.remove('active');
      }
      applyFilters();
    });

    // Toggle hidden items
    hiddenFilter.addEventListener('click', () => {
      showHidden = !showHidden;
      if (showHidden) {
        hiddenFilter.classList.add('active');
        hiddenFilter.textContent = 'Hide Archived';
        hiddenFilter.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
            <rect width="20" height="5" x="2" y="3" rx="1"></rect>
            <path d="M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8"></path>
            <path d="M10 12h4"></path>
          </svg>
          Hide Archived
        `;
      } else {
        hiddenFilter.classList.remove('active');
        hiddenFilter.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
            <rect width="20" height="5" x="2" y="3" rx="1"></rect>
            <path d="M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8"></path>
            <path d="M10 12h4"></path>
          </svg>
          Show Archived
        `;
      }
      applyFilters();
    });

    // Page size buttons
    pageSizeButtons.forEach(button => {
      button.addEventListener('click', () => {
        pageSizeButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        pageSize = parseInt(button.dataset.size);
        renderItems();
      });
    });

    // Modal close button
    modalClose.addEventListener('click', () => {
      closeModal();
    });

    // Close modal when clicking outside
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closeModal();
      }
    });

    // Initialize with MongoDB connection
    connectToMongoDB();
  });

  // Function to open the modal with conversation content
  function openConversationModal(item) {
    currentItemId = item.id;

    // Set title and user info
    document.getElementById('modal-title').textContent = "Conversation";
    document.getElementById('modal-username').textContent = `User: ${item.user}`;
    document.getElementById('modal-datetime').textContent = `Date: ${formatDateTime(item.datetime)}`;

    // Set conversation content
    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = '';

    if (item.conversation && item.conversation.length > 0) {
      item.conversation.forEach(message => {
        const messageElement = document.createElement('div');
        messageElement.className = `conversation-item ${message.role}`;
        messageElement.innerHTML = `
          <div class="conversation-bubble">
            <p class="conversation-role">${message.role === 'user' ? 'User' : 'Assistant'}</p>
            <p>${message.message}</p>
          </div>
        `;
        modalBody.appendChild(messageElement);
      });
    } else {
      modalBody.innerHTML = '<p>No conversation available</p>';
    }

    // Show modal with animation
    const modal = document.getElementById('feedback-modal');
    modal.classList.add('active');
  }

  // Function to open the modal with suggestion content
  function openSuggestionModal(item) {
    currentItemId = item.id;

    // Set title and user info
    document.getElementById('modal-title').textContent = "Suggestion";
    document.getElementById('modal-username').textContent = `User: ${item.user}`;
    document.getElementById('modal-datetime').textContent = `Date: ${formatDateTime(item.datetime)}`;

    // Set suggestion content
    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = '';

    const suggestionList = document.createElement('ul');
    suggestionList.className = 'suggestion-list';

    if (item.suggestions && item.suggestions.length > 0) {
      item.suggestions.forEach(suggestion => {
        const li = document.createElement('li');
        li.textContent = suggestion;
        suggestionList.appendChild(li);
      });
    } else {
      const li = document.createElement('li');
      li.textContent = 'No suggestions available';
      suggestionList.appendChild(li);
    }

    modalBody.appendChild(suggestionList);

    // Show modal with animation
    const modal = document.getElementById('feedback-modal');
    modal.classList.add('active');
  }

  // Function to open the modal with cypher query content
  function openCypherModal(item) {
    currentItemId = item.id;

    // Set title and user info
    document.getElementById('modal-title').textContent = "Cypher Query";
    document.getElementById('modal-username').textContent = `User: ${item.user}`;
    document.getElementById('modal-datetime').textContent = `Date: ${formatDateTime(item.datetime)}`;

    // Set cypher content
    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = '';

    const cypherList = document.createElement('ul');
    cypherList.className = 'cypher-list';

    if (item.cypherQueries && item.cypherQueries.length > 0) {
      item.cypherQueries.forEach(query => {
        const li = document.createElement('li');
        li.textContent = query;
        cypherList.appendChild(li);
      });
    } else {
      const li = document.createElement('li');
      li.textContent = 'No Cypher queries available';
      cypherList.appendChild(li);
    }

    modalBody.appendChild(cypherList);

    // Show modal with animation
    const modal = document.getElementById('feedback-modal');
    modal.classList.add('active');
  }

  // Function to close the modal
  function closeModal() {
    const modal = document.getElementById('feedback-modal');
    modal.classList.remove('active');
    currentItemId = null;
  }

  // Updated MongoDB data conversion focusing on required fields
  function convertMongoDataToAppFormat(mongoData) {
    if (!mongoData || !Array.isArray(mongoData)) {
      console.error("Invalid MongoDB data:", mongoData);
      return [];
    }

    try {
      return mongoData.map(item => {
        try {
          // Handle various message formats
          let parsedMessages;
          if (typeof item.messages === 'string') {
            parsedMessages = parseMessages(item.messages);
          } else if (Array.isArray(item.messages)) {
            parsedMessages = parseMessages(item.messages);
          } else {
            parsedMessages = [
              { role: 'user', message: 'No messages available' }
            ];
          }

          // Find the first user message for title
          const firstUserMessage = parsedMessages.find(msg => msg.role === 'user');

          // Extract suggestions if available (can be in different formats)
          let suggestions = [];
          if (item.suggest && typeof item.suggest === 'string') {
            // Try to parse if it's a JSON string
            try {
              suggestions = JSON.parse(item.suggest);
            } catch {
              // If not JSON, split by newlines or use as is
              suggestions = item.suggest.includes('\n') ?
                      item.suggest.split('\n').filter(Boolean) :
                      [item.suggest];
            }
          } else if (Array.isArray(item.suggest)) {
            suggestions = item.suggest;
          }

          // Extract cypher queries
          let cypherQueries = [];
          if (item.cypher && typeof item.cypher === 'string') {
            // Try to parse if it's a JSON string
            try {
              cypherQueries = JSON.parse(item.cypher);
            } catch {
              // If not JSON, split by newlines or use as is
              cypherQueries = item.cypher.includes('\n') ?
                      item.cypher.split('\n').filter(Boolean) :
                      [item.cypher];
            }
          } else if (Array.isArray(item.cypher)) {
            cypherQueries = item.cypher;
          }

          // Handle different MongoDB ID formats
          const id = item._id?.$oid || item._id || item.id;

          // Format the timestamp as a readable date
          let formattedDate = 'Unknown date';
          let rawDate = '';

          if (item.timestamp) {
            // Convert timestamp to Date object
            const date = new Date(
                    typeof item.timestamp === 'number' ?
                            item.timestamp * 1000 : // convert to milliseconds if it's a Unix timestamp
                            item.timestamp
            );
            formattedDate = isNaN(date) ? 'Invalid date' :
                    date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
            rawDate = item.timestamp;
          } else if (item.RDate && item.RDate.$date) {
            // Handle MongoDB Date format
            const date = new Date(
                    typeof item.RDate.$date === 'object' && item.RDate.$date.$numberLong ?
                            parseInt(item.RDate.$date.$numberLong) :
                            item.RDate.$date
            );
            formattedDate = isNaN(date) ? 'Invalid date' :
                    date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
            rawDate = date.toISOString();
          }

          return {
            id: id || `temp-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
            schema: item.schema || '',
            question: firstUserMessage ? firstUserMessage.message : 'No question found',
            conversation: parsedMessages,
            suggestions: suggestions,
            cypherQueries: cypherQueries,
            feedback: item.feedback || null,
            hidden: item.hidden || false,
            user: item.userName || 'Unknown',
            datetime: formattedDate,
            rawDate: rawDate,
            timestamp: item.timestamp || ''
          };
        } catch (itemError) {
          console.error("Error converting item:", itemError, item);
          return null;
        }
      }).filter(Boolean); // Remove any null items from errors
    } catch (error) {
      console.error("Error converting MongoDB data:", error);
      return [];
    }
  }

  // Memory-efficient message parsing
  function parseMessages(messagesString) {
    // Handle non-string input
    if (typeof messagesString !== 'string') {
      // If it's already an object/array, process it directly
      if (typeof messagesString === 'object' && messagesString !== null) {
        if (Array.isArray(messagesString)) {
          return messagesString.map(msg => ({
            role: msg.role || 'unknown',
            message: typeof msg.content === 'object' ?
                    JSON.stringify(msg.content) :
                    msg.content || 'No content'
          }));
        }

        // If single object, convert to array
        return [{
          role: messagesString.role || 'unknown',
          message: typeof messagesString.content === 'object' ?
                  JSON.stringify(messagesString.content) :
                  messagesString.content || 'No content'
        }];
      }

      // Return default for non-string non-object
      console.warn('Messages is not a string or object:', messagesString);
      return [
        { role: 'user', message: 'Message parsing error' },
        { role: 'assistant', message: 'Unable to parse messages' }
      ];
    }

    try {
      // Clean the string to make it more JSON-like
      let cleanedString = messagesString
              .replace(/([a-zA-Z]+)=/g, '"$1":')  // Convert property=value to "property":value
              .replace(/'/g, '"')                  // Replace single quotes with double quotes
              .replace(/\"\{/g, '{')              // Fix any malformed quotes before brackets
              .replace(/\}\"/g, '}');             // Fix any malformed quotes after brackets

      // Try to parse as JSON
      try {
        const parsed = JSON.parse(cleanedString);
        if (Array.isArray(parsed)) {
          return parsed.map(msg => ({
            role: msg.role || 'unknown',
            message: typeof msg.content === 'object' ?
                    (msg.content.reduced_user_message || JSON.stringify(msg.content)) :
                    msg.content || 'No content'
          }));
        }
      } catch (jsonError) {
        // Continue to regex approach if JSON parsing fails
      }

      // Use regex to extract content - covers most common formats
      const regex = /\{(?:['"]?role['"]?[:=]\s*['"]?(.*?)['"]?[,}]).*?(?:['"]?content['"]?[:=]\s*(.*?)(?=\s*[,}]|$))/g;
      const matches = [];
      let match;

      while ((match = regex.exec(messagesString)) !== null) {
        const role = match[1]?.trim() || 'unknown';
        let content = match[2];

        // Clean up content
        if (content) {
          // Remove surrounding quotes if present
          content = content.replace(/^['"]|['"]$/g, '');

          // Handle object content - simplified approach
          if (content.startsWith('{') && content.endsWith('}')) {
            try {
              const contentObj = JSON.parse(content.replace(/'/g, '"'));
              content = contentObj.reduced_user_message || JSON.stringify(contentObj);
            } catch (e) {
              // Keep as is if parsing fails
            }
          }
        }

        matches.push({
          role: role,
          message: content || 'No content'
        });
      }

      if (matches.length > 0) {
        return matches;
      }

      // Last resort simple format detection
      if (messagesString.includes('role') && messagesString.includes('content')) {
        const items = messagesString.split('},').map(part => part.trim() + (part.endsWith('}') ? '' : '}'));

        return items.map(item => {
          const roleMatch = item.match(/role['":\s=]+(['"]?)(.*?)\1[,}]/i);
          const contentMatch = item.match(/content['":\s=]+(['"]?)(.*?)\1[,}]/i);

          return {
            role: roleMatch ? roleMatch[2].trim() : 'unknown',
            message: contentMatch ? contentMatch[2].trim() : 'No content'
          };
        });
      }

      // Return default for unparseable content
      return [
        { role: 'user', message: 'Error parsing message content' }
      ];
    } catch (error) {
      console.error("Critical error parsing messages:", error);
      return [
        { role: 'user', message: 'Error parsing message' }
      ];
    }
  }

  // Connect to MongoDB via API with pagination
  async function connectToMongoDB(page = 0) {
    try {
      // Show connecting status
      connectionIndicator.classList.remove('connected');
      connectionIndicator.classList.remove('disconnected');
      connectionText.textContent = `Connecting to MongoDB (page ${page + 1})...`;

      // Clear existing data
      data = [];
      filteredData = [];

      // Fetch data from our backend API with pagination
      const response = await fetch(`${API_BASE_URL}/conversations?page=${page}&limit=${pageSize}`);

      if (!response.ok) {
        throw new Error(`API responded with status: ${response.status}`);
      }

      const result = await response.json();
      console.log("API response:", result);

      let mongoData;
      if (result.data) {
        mongoData = result.data;

        // Update pagination info
        currentPage = result.pagination.page;
        totalPages = result.pagination.totalPages;
      } else {
        // Handle old API format
        mongoData = result;
        currentPage = 0;
        totalPages = 1;
      }

      // Update connection status
      connectionIndicator.classList.add('connected');
      connectionText.textContent = `Connected to MongoDB - ${mongoData.length} records loaded`;

      if (result.pagination) {
        connectionText.textContent += ` (Page ${currentPage + 1} of ${totalPages} - Total: ${result.pagination.totalCount})`;
      }

      // Convert and store data
      data = convertMongoDataToAppFormat(mongoData);
      console.log("Converted data:", data);

      filteredData = [...data.filter(item => !item.hidden)];

      // Initialize tabs
      initializeTabs(totalPages);

      // Render items
      renderItems();

    } catch (error) {
      console.error('Error connecting to MongoDB:', error);
      connectionIndicator.classList.add('disconnected');
      connectionText.textContent = 'Failed to connect to MongoDB: ' + error.message;

      // For development/testing - use sample data in case of error
      if (confirm('Connection to API failed. Use sample data instead?')) {
        // Create some sample data
        const sampleData = [
          {
            id: "sample1",
            schema: "Mesai",
            question: "What are my work hours this week?",
            conversation: [
              { role: "user", message: "What are my work hours this week?" },
              { role: "assistant", message: "Your work hours for this week are:\nMonday: 9 AM - 5 PM\nTuesday: 9 AM - 5 PM\nWednesday: 10 AM - 6 PM\nThursday: 9 AM - 5 PM\nFriday: 9 AM - 4 PM" }
            ],
            suggestions: [
              "You might want to check your overtime hours for last week",
              "Would you like to request time off?",
              "Do you need to see your vacation balance?"
            ],
            cypherQueries: [
              "MATCH (e:Employee {id: '12345'})-[:HAS_SCHEDULE]->(s:Schedule) WHERE s.week = '2023-W42' RETURN s",
              "MATCH (e:Employee {id: '12345'})-[:WORKED]->(h:Hours) WHERE h.date >= '2023-10-16' RETURN h"
            ],
            feedback: "positive",
            hidden: false,
            user: "testuser1",
            datetime: "2023-10-20 14:32:45"
          },
          {
            id: "sample2",
            schema: "Mukavele",
            question: "When does my contract expire?",
            conversation: [
              { role: "user", message: "When does my contract expire?" },
              { role: "assistant", message: "Your current contract expires on December 31, 2023. Would you like information about the renewal process?" }
            ],
            suggestions: [
              "You might want to review your contract terms",
              "Would you like to schedule a meeting with HR about renewal?",
              "Do you need information about contract extensions?"
            ],
            cypherQueries: [
              "MATCH (e:Employee {id: '12345'})-[:HAS_CONTRACT]->(c:Contract) RETURN c.expiryDate",
              "MATCH (c:Contract)-[:HAS_TERMS]->(t:Terms) WHERE c.employeeId = '12345' RETURN t"
            ],
            feedback: "negative",
            hidden: false,
            user: "testuser2",
            datetime: "2023-10-19 10:15:30"
          },
          {
            id: "sample3",
            schema: "Genel",
            question: "How do I request vacation time?",
            conversation: [
              { role: "user", message: "How do I request vacation time?" },
              { role: "assistant", message: "To request vacation time, you need to:\n1. Log into the employee portal\n2. Go to 'Time Off' section\n3. Click 'Request Time Off'\n4. Select the dates and type of leave\n5. Submit for approval" }
            ],
            suggestions: [
              "You currently have 15 vacation days available",
              "Would you like to see the company holiday calendar?",
              "Do you need information about sick leave policy?"
            ],
            cypherQueries: [
              "MATCH (e:Employee {id: '12345'})-[:HAS_BENEFITS]->(b:Benefits) RETURN b.vacationDays",
              "MATCH (p:Policy {type: 'vacation'})-[:APPLIES_TO]->(d:Department {id: '54321'}) RETURN p"
            ],
            feedback: null,
            hidden: true,
            user: "testuser3",
            datetime: "2023-10-18 09:45:12"
          }
        ];

        data = sampleData;
        filteredData = [...data.filter(item => !item.hidden)];

        // Mock pagination for sample data
        currentPage = 0;
        totalPages = 1;
        initializeTabs(totalPages);

        renderItems();
      }
    }
  }

  // Initialize tab navigation
  function initializeTabs(totalPages) {
    const tabsList = document.getElementById('tabs-list');
    const prevTabBtn = document.getElementById('prev-tab-btn');
    const nextTabBtn = document.getElementById('next-tab-btn');

    if (!tabsList || !prevTabBtn || !nextTabBtn) return;

    // Clear existing tabs
    tabsList.innerHTML = '';

    // Create tabs
    for (let i = 0; i < totalPages; i++) {
      const tab = document.createElement('button');
      tab.className = `pagination-btn${currentPage === i ? ' active' : ''}`;
      tab.textContent = `Page ${i + 1}`;
      tab.dataset.page = i;

      tab.addEventListener('click', () => {
        if (currentPage !== i) {
          loadPage(i);
        }
      });

      tabsList.appendChild(tab);
    }

    // Update tab visibility based on current page
    updateTabsVisibility();

    // Update navigation buttons
    prevTabBtn.disabled = currentPage === 0;
    nextTabBtn.disabled = currentPage === totalPages - 1;

    // Add event listeners to navigation buttons
    prevTabBtn.addEventListener('click', () => {
      if (currentPage > 0) {
        loadPage(currentPage - 1);
      }
    });

    nextTabBtn.addEventListener('click', () => {
      if (currentPage < totalPages - 1) {
        loadPage(currentPage + 1);
      }
    });
  }

  // Load specific page
  async function loadPage(page) {
    // Show loading state
    connectionText.textContent = `Loading page ${page + 1}...`;

    try {
      // Fetch data for specific page
      const response = await fetch(`${API_BASE_URL}/conversations?page=${page}&limit=${pageSize}`);

      if (!response.ok) {
        throw new Error(`API responded with status: ${response.status}`);
      }

      const result = await response.json();
      const mongoData = result.data;

      // Update current page
      currentPage = page;

      // Convert and store data
      data = convertMongoDataToAppFormat(mongoData);
      filteredData = [...data.filter(item => !item.hidden)];

      // Update tabs
      const tabButtons = document.querySelectorAll('.pagination-btn');
      tabButtons.forEach(tab => {
        const tabPage = parseInt(tab.dataset.page);
        tab.classList.toggle('active', tabPage === currentPage);
      });

      // Update tab visibility
      updateTabsVisibility();

      // Update navigation buttons
      document.getElementById('prev-tab-btn').disabled = currentPage === 0;
      document.getElementById('next-tab-btn').disabled = currentPage === totalPages - 1;

      // Update connection status
      connectionText.textContent = `Page ${currentPage + 1} of ${totalPages} - Total records: ${result.pagination.totalCount}`;

      // Render items
      renderItems();

    } catch (error) {
      console.error('Error loading page:', error);
      connectionText.textContent = `Failed to load page ${page + 1}: ${error.message}`;
    }
  }

  // Update which tabs are visible
  function updateTabsVisibility() {
    const tabButtons = document.querySelectorAll('.pagination-btn');

    // Calculate start and end indexes for visible tabs
    let startIndex = Math.max(0, currentPage - Math.floor(visibleTabCount / 2));
    let endIndex = Math.min(totalPages - 1, startIndex + visibleTabCount - 1);

    // Adjust start index if needed
    if (endIndex - startIndex + 1 < visibleTabCount) {
      startIndex = Math.max(0, endIndex - visibleTabCount + 1);
    }

    // Show/hide tabs based on calculated range
    tabButtons.forEach((tab, index) => {
      tab.style.display = (index >= startIndex && index <= endIndex) ? 'block' : 'none';
    });
  }

  // Filter by schema
  function filterBySchema(schema) {
    const button = document.querySelector(`.filter-btn[data-schema="${schema}"]`);

    if (!button) return;

    if (activeSchema === schema) {
      activeSchema = null;
      button.classList.remove('active');
    } else {
      // Remove active class from all schema buttons
      document.querySelectorAll('.filter-btn[data-schema]').forEach(btn => {
        btn.classList.remove('active');
      });

      activeSchema = schema;
      button.classList.add('active');
    }

    applyFilters();
  }

  // Apply all filters
  function applyFilters() {
    let filtered = [...data];

    // Apply schema filter if active
    if (activeSchema) {
      filtered = filtered.filter(item => item.schema === activeSchema);
    }

    // Apply feedback filter if active
    if (activeFeedbackFilter) {
      filtered = filtered.filter(item => item.feedback === activeFeedbackFilter);
    }

    // Apply hidden filter
    if (!showHidden) {
      filtered = filtered.filter(item => !item.hidden);
    }

    // Apply search query
    if (searchQuery) {
      filtered = filtered.filter(item =>
              (item.question && item.question.toLowerCase().includes(searchQuery)) ||
              (item.conversation && item.conversation.some(msg =>
                      msg.message.toLowerCase().includes(searchQuery)
              )) ||
              (item.user && item.user.toLowerCase().includes(searchQuery))
      );
    }

    filteredData = filtered;
    renderItems();
  }

  // Render feedback items with the updated design
  function renderItems() {
    const feedbackItems = document.getElementById('feedback-items');
    const noResults = document.getElementById('no-results');
    const resultsCount = document.getElementById('results-count');

    if (!feedbackItems || !noResults || !resultsCount) return;

    // Update results count
    resultsCount.textContent = `Showing ${Math.min(pageSize, filteredData.length)} of ${filteredData.length} results`;

    // Clear items container
    feedbackItems.innerHTML = '';

    // Show or hide no results message
    if (filteredData.length === 0) {
      noResults.classList.remove('hidden');
    } else {
      noResults.classList.add('hidden');

      // Render items
      filteredData.slice(0, pageSize).forEach((item, index) => {
        // Create main feedback item container
        const itemElement = document.createElement('div');
        itemElement.className = 'feedback-item';
        itemElement.dataset.id = item.id;

        // Create schema buttons column
        const schemaButtons = document.createElement('div');
        schemaButtons.className = 'schema-buttons';

        // Add schema buttons
        schemaList.forEach(schema => {
          const button = document.createElement('button');
          button.className = `schema-btn${item.schema === schema ? ' active' : ''}`;
          button.textContent = schema;
          button.dataset.schema = schema;

          button.addEventListener('click', (e) => {
            e.stopPropagation(); // Don't open the modal when clicking schema buttons
            setSchema(item.id, schema);
          });

          schemaButtons.appendChild(button);
        });

        // Create content area with user info and buttons
        const contentArea = document.createElement('div');
        contentArea.className = 'feedback-content';

        // Add user info section
        const userInfo = document.createElement('div');
        userInfo.className = 'feedback-user-info';
        userInfo.innerHTML = `
          <span class="user-name">User: ${item.user}</span>
          <span class="datetime">${formatDateTime(item.datetime)}</span>
        `;
        contentArea.appendChild(userInfo);

        // Create buttons container
        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'feedback-buttons';

        // Create large conversation button
        const conversationBtn = document.createElement('button');
        conversationBtn.className = 'conversation-btn';
        conversationBtn.textContent = item.question;
        conversationBtn.addEventListener('click', () => {
          openConversationModal(item);
        });

        // Create container for small buttons
        const smallButtons = document.createElement('div');
        smallButtons.className = 'small-buttons';

        // Create suggestion button
        const suggestionBtn = document.createElement('button');
        suggestionBtn.className = 'suggestion-btn';
        suggestionBtn.textContent = 'Suggestion';
        suggestionBtn.addEventListener('click', () => {
          openSuggestionModal(item);
        });

        // Create cypher button
        const cypherBtn = document.createElement('button');
        cypherBtn.className = 'cypher-btn';
        cypherBtn.textContent = 'Cypher Query';
        cypherBtn.addEventListener('click', () => {
          openCypherModal(item);
        });

        // Add small buttons to container
        smallButtons.appendChild(suggestionBtn);
        smallButtons.appendChild(cypherBtn);

        // Add buttons to container
        buttonsContainer.appendChild(conversationBtn);
        buttonsContainer.appendChild(smallButtons);

        // Add buttons container to content area
        contentArea.appendChild(buttonsContainer);

        // Create the actions column
        const actions = document.createElement('div');
        actions.className = 'feedback-actions';

        // Positive button (thumbs up)
        const positiveBtn = document.createElement('button');
        positiveBtn.className = `action-btn positive${item.feedback === 'positive' ? ' active' : ''}`;
        positiveBtn.dataset.action = 'positive';
        positiveBtn.innerHTML = `
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M7 10v12"></path>
            <path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z"></path>
          </svg>
        `;

        positiveBtn.addEventListener('click', (e) => {
          e.stopPropagation(); // Don't open the modal
          handlePositiveFeedback(item.id);
        });

        // Archive button (now in middle position)
        const archiveBtn = document.createElement('button');
        archiveBtn.className = `action-btn archive${item.hidden ? ' active' : ''}`;
        archiveBtn.dataset.action = 'archive';
        archiveBtn.innerHTML = `
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect width="20" height="5" x="2" y="3" rx="1"></rect>
            <path d="M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8"></path>
            <path d="M10 12h4"></path>
          </svg>
        `;

        archiveBtn.addEventListener('click', (e) => {
          e.stopPropagation(); // Don't open the modal
          handleToggleHidden(item.id);
        });

        // Negative button (thumbs down) - now last
        const negativeBtn = document.createElement('button');
        negativeBtn.className = `action-btn negative${item.feedback === 'negative' ? ' active' : ''}`;
        negativeBtn.dataset.action = 'negative';
        negativeBtn.innerHTML = `
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M17 14V2"></path>
            <path d="M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22h0a3.13 3.13 0 0 1-3-3.88Z"></path>
          </svg>
        `;

        negativeBtn.addEventListener('click', (e) => {
          e.stopPropagation(); // Don't open the modal
          handleNegativeFeedback(item.id);
        });

        // Add action buttons to actions container in the new order
        actions.appendChild(positiveBtn);
        actions.appendChild(archiveBtn);
        actions.appendChild(negativeBtn);

        // Add all parts to the item
        itemElement.appendChild(schemaButtons);
        itemElement.appendChild(contentArea);
        itemElement.appendChild(actions);

        // Add to the container
        feedbackItems.appendChild(itemElement);
      });
    }
  }

  // Handle positive feedback
  async function handlePositiveFeedback(id) {
    const item = data.find(item => item.id === id);
    if (!item) return;

    // If already positive, remove feedback
    const newFeedback = item.feedback === 'positive' ? null : 'positive';

    // Update data locally first
    data = data.map(item => {
      if (item.id === id) {
        return { ...item, feedback: newFeedback };
      }
      return item;
    });

    // Update MongoDB via API
    try {
      const response = await fetch(`${API_BASE_URL}/conversations/${id}/feedback`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ feedback: newFeedback })
      });

      if (!response.ok) {
        console.error('Error updating feedback:', await response.text());
      }
    } catch (error) {
      console.error('Failed to update feedback:', error);
    }

    // Apply filters to update UI
    applyFilters();
  }

  // Handle negative feedback
  async function handleNegativeFeedback(id) {
    const item = data.find(item => item.id === id);
    if (!item) return;

    // If already negative, remove feedback
    const newFeedback = item.feedback === 'negative' ? null : 'negative';

    // Update data locally first
    data = data.map(item => {
      if (item.id === id) {
        return { ...item, feedback: newFeedback };
      }
      return item;
    });

    // Update MongoDB via API
    try {
      const response = await fetch(`${API_BASE_URL}/conversations/${id}/feedback`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ feedback: newFeedback })
      });

      if (!response.ok) {
        console.error('Error updating feedback:', await response.text());
      }
    } catch (error) {
      console.error('Failed to update feedback:', error);
    }

    // Apply filters to update UI
    applyFilters();
  }

  // Handle toggle hidden
  async function handleToggleHidden(id) {
    const item = data.find(item => item.id === id);
    if (!item) return;

    // Toggle hidden state
    const newHiddenState = !item.hidden;

    // Update data locally first
    data = data.map(item => {
      if (item.id === id) {
        return { ...item, hidden: newHiddenState };
      }
      return item;
    });

    // Update MongoDB via API
    try {
      const response = await fetch(`${API_BASE_URL}/conversations/${id}/archive`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ hidden: newHiddenState })
      });

      if (!response.ok) {
        console.error('Error updating archive status:', await response.text());
      }
    } catch (error) {
      console.error('Failed to update archive status:', error);
    }

    // Apply filters to update UI
    applyFilters();
  }

  // Set schema for an item
  async function setSchema(id, schema) {
    const item = data.find(item => item.id === id);
    if (!item) return;

    // Update schema locally first
    const oldSchema = item.schema;
    item.schema = schema;

    // Update schema buttons in this item
    const itemElement = document.querySelector(`.feedback-item[data-id="${id}"]`);
    if (itemElement) {
      const schemaButtons = itemElement.querySelectorAll('.schema-btn');
      schemaButtons.forEach(button => {
        const buttonSchema = button.dataset.schema;
        button.classList.toggle('active', buttonSchema === schema);
      });
    }

    // Update MongoDB via API
    try {
      const response = await fetch(`${API_BASE_URL}/conversations/${id}/schema`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ schema })
      });

      if (!response.ok) {
        console.error('Error updating schema:', await response.text());
        // Revert to old schema if update failed
        item.schema = oldSchema;
        if (itemElement) {
          const schemaButtons = itemElement.querySelectorAll('.schema-btn');
          schemaButtons.forEach(button => {
            const buttonSchema = button.dataset.schema;
            button.classList.toggle('active', buttonSchema === oldSchema);
          });
        }
        alert('Failed to update schema on server. Please try again.');
        return;
      }

      // Apply filters to update UI if needed
      if (activeSchema) {
        applyFilters();
      }
    } catch (error) {
      console.error('Failed to update schema:', error);
      // Revert to old schema if update failed
      item.schema = oldSchema;
      if (itemElement) {
        const schemaButtons = itemElement.querySelectorAll('.schema-btn');
        schemaButtons.forEach(button => {
          const buttonSchema = button.dataset.schema;
          button.classList.toggle('active', buttonSchema === oldSchema);
        });
      }
      alert('Failed to update schema: ' + error.message);
    }
  }
</script>

<!-- Include fix scripts -->
<script src="continuous-loading-fix.js"></script>
<script src="feedback-system-fixes.js"></script>
<script src="feedback-system-fixes-2.js"></script>
<script src="pagination-fix.js"></script>
<script src="similarity-fix.js"></script>
<script src="debug-mode.js"></script>
</body>
</html>