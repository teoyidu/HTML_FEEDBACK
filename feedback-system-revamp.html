<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Chatbot Feedback System</title>
  <style>
    /* General styles */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background-color: #111827;
      color: #f3f4f6;
      line-height: 1.5;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
    }

    h1 {
      font-size: 1.5rem;
      font-weight: bold;
      margin-bottom: 1.5rem;
    }

    /* Search bar */
    .search-container {
      position: relative;
      margin-bottom: 1.5rem;
    }

    .search-icon {
      position: absolute;
      left: 0.75rem;
      top: 50%;
      transform: translateY(-50%);
      color: #9ca3af;
    }

    .search-input {
      width: 100%;
      padding: 0.625rem 0.75rem 0.625rem 2.5rem;
      background-color: #1f2937;
      border: 1px solid #374151;
      border-radius: 0.5rem;
      color: #f3f4f6;
      font-size: 0.875rem;
    }

    .search-input:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 1px #3b82f6;
    }
    /* QDrant Panel Styles */
    .qdrant-panel {
      position: fixed;
      top: 70px;
      right: 20px;
      width: 300px;
      background-color: #1f2937;
      border-radius: 0.5rem;
      padding: 1rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 40;
      border: 1px solid #374151;
    }

    .qdrant-panel h3 {
      margin-top: 0;
      margin-bottom: 1rem;
      font-size: 1.1rem;
      color: #e5e7eb;
      border-bottom: 1px solid #374151;
      padding-bottom: 0.5rem;
    }

    .qdrant-input-group {
      margin-bottom: 1rem;
    }

    .qdrant-input-group label {
      display: block;
      margin-bottom: 0.25rem;
      color: #d1d5db;
      font-size: 0.875rem;
    }

    .qdrant-input-group textarea {
      width: 100%;
      min-height: 80px;
      padding: 0.5rem;
      background-color: #2d3748;
      color: #e5e7eb;
      border: 1px solid #4b5563;
      border-radius: 0.25rem;
      font-size: 0.875rem;
      resize: vertical;
    }

    .qdrant-input-group textarea:focus {
      border-color: #2563eb;
      outline: none;
      box-shadow: 0 0 0 1px #2563eb;
    }

    .qdrant-send-btn {
      width: 100%;
      padding: 0.5rem;
      background-color: #2563eb;
      color: white;
      border: none;
      border-radius: 0.25rem;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .qdrant-send-btn:hover {
      background-color: #1d4ed8;
    }

    .highlighted {
      animation: highlight-pulse 2s ease;
    }

    @keyframes highlight-pulse {
      0%, 100% { border-color: #4b5563; }
      50% { border-color: #2563eb; box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.3); }
    }

    /* QDrant Confirmation Dialog */
    .qdrant-confirm-dialog {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .qdrant-confirm-content {
      background-color: #1f2937;
      border-radius: 0.5rem;
      padding: 1.5rem;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }

    .qdrant-confirm-title {
      font-size: 1.1rem;
      margin-top: 0;
      margin-bottom: 1rem;
      font-weight: 500;
    }

    .qdrant-confirm-text {
      margin-bottom: 1.5rem;
      color: #d1d5db;
    }

    .qdrant-confirm-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 0.75rem;
    }

    .qdrant-confirm-btn {
      padding: 0.5rem 1rem;
      border-radius: 0.25rem;
      font-size: 0.875rem;
      cursor: pointer;
    }

    .qdrant-confirm-btn.cancel {
      background-color: #4b5563;
      color: #e5e7eb;
      border: none;
    }

    .qdrant-confirm-btn.confirm {
      background-color: #2563eb;
      color: white;
      border: none;
    }
    /* Schema Toggle Switch Styles */
    .schema-toggle-container {
      display: flex;
      align-items: center;
      margin-bottom: 1rem;
      padding: 0.5rem;
      background-color: #1f2937;
      border-radius: 0.5rem;
      border: 1px solid #374151;
    }

    .schema-toggle-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      padding: 0 0.5rem;
    }

    .schema-option {
      font-weight: 500;
      transition: color 0.3s;
    }

    .schema-option.active {
      color: #2563eb;
    }

    .schema-option.inactive {
      color: #6b7280;
    }

    /* Toggle Switch */
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 30px;
      margin: 0 1rem;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #374151;
      transition: .4s;
      border-radius: 34px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 22px;
      width: 22px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .toggle-slider {
      background-color: #2563eb;
    }

    input:checked + .toggle-slider:before {
      transform: translateX(30px);
    }

    /* Schema Icon Selection Styles */
    .schema-selector-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1rem;
      padding: 0.5rem 0;
      border-bottom: 1px solid #374151;
    }

    .schema-option-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background-color: transparent;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      cursor: pointer;
      transition: all 0.2s ease;
      color: #9ca3af;
      flex: 1;
    }

    .schema-option-btn .schema-icon {
      width: 30px;
      height: 30px;
      margin-bottom: 0.5rem;
      transition: all 0.2s ease;
      stroke: #9ca3af;
      fill: none;
    }

    .schema-option-btn .schema-label {
      font-size: 0.875rem;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    .schema-option-btn.selected {
      background-color: #1e3a8a;
      color: white;
    }

    .schema-option-btn.selected .schema-icon {
      stroke: white;
    }

    .schema-option-btn:hover:not(.selected) {
      background-color: #374151;
      color: #d1d5db;
    }

    .schema-option-btn:hover:not(.selected) .schema-icon {
      stroke: #d1d5db;
    }

    .schema-selector-divider {
      width: 1px;
      height: 40px;
      background-color: #374151;
      margin: 0 0.5rem;
    }

    /* QDrant View specific styles - add to the CSS file */

    .qdrant-toggle-container {
      margin: 1rem 0;
      display: flex;
      justify-content: flex-end;
    }

    .qdrant-toggle-btn {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      background-color: #6366F1;
      color: white;
      border: none;
      border-radius: 0.375rem;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .qdrant-toggle-btn:hover {
      background-color: #4F46E5;
    }

    .qdrant-toggle-btn svg {
      transition: transform 0.3s ease;
    }

    .qdrant-toggle-btn.active svg {
      transform: rotate(45deg);
    }

    .qdrant-view-container {
      margin-top: 1.5rem;
    }

    .qdrant-view-container h2 {
      color: #F9FAFB;
      margin-bottom: 1rem;
      font-size: 1.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .qdrant-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-bottom: 1.5rem;
      padding: 1rem;
      background-color: #1F2937;
      border-radius: 0.5rem;
    }

    .qdrant-filter,
    .qdrant-search {
      flex: 1;
      min-width: 200px;
    }

    .qdrant-select,
    .qdrant-input {
      width: 100%;
      padding: 0.5rem;
      background-color: #111827;
      color: #F9FAFB;
      border: 1px solid #374151;
      border-radius: 0.375rem;
      font-size: 0.875rem;
    }

    .qdrant-select:focus,
    .qdrant-input:focus {
      outline: none;
      border-color: #6366F1;
      box-shadow: 0 0 0 1px #6366F1;
    }

    .qdrant-items-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 1rem;
    }

    .qdrant-item {
      background-color: #1F2937;
      border-radius: 0.5rem;
      overflow: hidden;
      border-top: 4px solid #6366F1;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .qdrant-item:hover {
      transform: translateY(-4px);
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }

    .qdrant-item-header {
      padding: 1rem;
      background-color: #111827;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .qdrant-item-schema {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      background-color: #4B5563;
      color: white;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 500;
    }

    .qdrant-item-group {
      color: #9CA3AF;
      font-size: 0.75rem;
    }

    .qdrant-item-body {
      padding: 1rem;
    }

    .qdrant-item-message {
      margin-bottom: 1rem;
      font-size: 1rem;
      color: #F9FAFB;
      line-height: 1.5;
    }

    .qdrant-item-cypher {
      padding: 0.75rem;
      background-color: #111827;
      border-radius: 0.375rem;
      font-family: monospace;
      font-size: 0.875rem;
      color: #D1D5DB;
      white-space: pre-wrap;
      word-break: break-word;
      margin-bottom: 1rem;
      overflow-x: auto;
    }

    .qdrant-item-version {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.5rem;
      background-color: #374151;
      color: #D1D5DB;
      border-radius: 0.25rem;
      font-size: 0.75rem;
    }

    .qdrant-no-items {
      padding: 3rem;
      text-align: center;
      color: #9CA3AF;
      background-color: #1F2937;
      border-radius: 0.5rem;
      margin-top: 1rem;
    }

    /* Hide regular content when in QDrant view mode */
    .qdrant-mode .filter-section,
    .qdrant-mode .feedback-filters,
    .qdrant-mode .page-size,
    .qdrant-mode .sort-controls,
    .qdrant-mode .date-range-filter,
    .qdrant-mode .tabs-container,
    .qdrant-mode #results-count,
    .qdrant-mode #feedback-items,
    .qdrant-mode #no-results,
    .qdrant-mode .search-container {
      display: none !important;
    }

    /* Filter styles */
    .filter-section {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }

    .filter-label {
      display: flex;
      align-items: center;
      margin-right: 0.5rem;
    }

    .filter-label svg {
      margin-right: 0.25rem;
    }

    .filter-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .filter-btn {
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.875rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: none;
      cursor: pointer;
      transition: background-color 0.2s;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .filter-btn:hover {
      background-color: #374151;
    }

    .filter-btn.active {
      background-color: #2563eb;
      color: white;
    }

    /* Feedback filters */
    .feedback-filters {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      border-top: 1px solid #374151;
      padding-top: 1rem;
    }

    /* Page size buttons */
    .page-size {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      align-items: center;
    }

    .page-size-btn {
      padding: 0.25rem 0.75rem;
      border-radius: 0.25rem;
      font-size: 0.875rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: none;
      cursor: pointer;
    }

    .page-size-btn.active {
      background-color: #374151;
      color: white;
    }

    /* Results count */
    .results-count {
      margin-bottom: 1rem;
      color: #9ca3af;
      font-size: 0.875rem;
    }

    /* Content with formatting support */
    .conversation-content, .cypher-query, .suggestion-list li {
      white-space: pre-wrap;
      word-wrap: break-word;
      line-height: 1.5;
    }

    /* Sort controls */
    .sort-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }

    .sort-btn {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.25rem 0.75rem;
      border-radius: 0.25rem;
      font-size: 0.875rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: none;
      cursor: pointer;
    }

    .sort-btn:hover {
      background-color: #374151;
    }

    .sort-btn.active {
      background-color: #2563eb;
      color: white;
    }
    /* Date range filter */
    .date-range-filter {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
    }

    .date-inputs {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .date-input-group {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .date-input {
      padding: 0.35rem 0.5rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: 1px solid #374151;
      border-radius: 0.25rem;
      font-size: 0.875rem;
    }

    .date-input:focus {
      border-color: #3b82f6;
      outline: none;
    }

    /* Cypher query styling */
    .cypher-query {
      background-color: #2d3748;
      padding: 0.75rem;
      border-radius: 0.25rem;
      margin-bottom: 1rem;
      font-family: monospace;
      font-size: 0.9rem;
      overflow-x: auto;
    }

    /* Enhance the suggestion list */
    .suggestion-list li {
      padding: 0.75rem;
      background-color: #374151;
      border-radius: 0.5rem;
      margin-bottom: 0.75rem;
    }
    /* Additional data buttons styles */
    .additional-data-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .data-btn {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.4rem 0.6rem;
      background-color: #2d3748;
      color: #d1d5db;
      border: none;
      border-radius: 0.375rem;
      font-size: 0.75rem;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.2s;
    }

    .data-btn:hover:not(:disabled) {
      background-color: #4a5568;
      transform: translateY(-1px);
    }

    .data-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .data-btn svg {
      width: 14px;
      height: 14px;
    }

    /* Data popup styles */
    .data-popup {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.75);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    .data-popup.active {
      opacity: 1;
      visibility: visible;
    }

    .popup-content {
      background-color: #1f2937;
      border-radius: 0.5rem;
      width: 90%;
      max-width: 900px;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
      transform: scale(0.9);
      transition: transform 0.3s ease;
    }

    .data-popup.active .popup-content {
      transform: scale(1);
    }

    .popup-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      border-bottom: 1px solid #374151;
    }

    .popup-header h3 {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 500;
    }

    .popup-close {
      background: none;
      border: none;
      color: #9ca3af;
      cursor: pointer;
      padding: 0.25rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 0.25rem;
      transition: background-color 0.2s;
    }

    .popup-close:hover {
      background-color: #374151;
    }

    .popup-body {
      padding: 1rem;
      overflow-y: auto;
      flex: 1;
    }

    .popup-body pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: monospace;
      font-size: 0.9rem;
      line-height: 1.5;
      color: #d1d5db;
      margin: 0;
      padding: 0.5rem;
      background-color: #2d3748;
      border-radius: 0.25rem;
      overflow-x: auto;
    }

    /* MongoDB Connection Styles */
    .connection-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
      font-size: 0.875rem;
    }

    .connection-status .status-indicator {
      width: 0.75rem;
      height: 0.75rem;
      border-radius: 50%;
      background-color: #9ca3af;
    }

    .connection-status .status-indicator.connected {
      background-color: #10b981;
    }

    .connection-status .status-indicator.disconnected {
      background-color: #ef4444;
    }

    /* Feedback items */
    .feedback-items {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .feedback-item {
      position: relative;
      display: flex;
      border-radius: 0.5rem;
      background-color: #1f2937;
      overflow: hidden;
      animation: fadeIn 0.3s ease-out;
      transition: all 0.3s ease;
    }

    /* Schema buttons on the left */
    .schema-buttons {
      display: flex;
      flex-direction: column;
      padding: 1rem;
      background-color: #1f2937;
      border-right: 1px solid #374151;
      min-width: 120px;
      justify-content: center;
      align-items: center;
      gap: 0.5rem;
    }

    .schema-btn {
      display: block;
      width: 100%;
      padding: 0.5rem;
      border-radius: 0.5rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: 1px solid #374151;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
    }

    .schema-btn:hover {
      background-color: #2d3748;
    }

    .schema-btn.active {
      background-color: #2563eb;
      color: white;
      border-color: #2563eb;
    }

    /* Content buttons in the middle */
    .feedback-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      padding: 1rem;
    }

    /* User info at top */
    .feedback-user-info {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: #9ca3af;
      border-bottom: 1px solid #374151;
      padding-bottom: 0.5rem;
    }

    .user-name {
      font-weight: 500;
    }

    .datetime {
      font-style: italic;
    }

    /* Conversation and action buttons */
    .feedback-buttons {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .conversation-btn {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      background-color: #374151;
      border: none;
      border-radius: 0.5rem;
      color: white;
      font-size: 1rem;
      text-align: left;
      cursor: pointer;
      transition: background-color 0.2s;
      min-height: 60px;
    }

    .conversation-btn:hover {
      background-color: #4b5563;
    }

    .small-buttons {
      display: flex;
      gap: 0.5rem;
      width: 100%;
    }

    .suggestion-btn, .cypher-btn {
      flex: 1;
      padding: 0.5rem;
      background-color: #374151;
      border: none;
      border-radius: 0.5rem;
      color: white;
      font-size: 0.875rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .suggestion-btn:hover, .cypher-btn:hover {
      background-color: #4b5563;
    }

    /* Feedback actions on the right */
    .feedback-actions {
      display: flex;
      flex-direction: column;
      padding: 1rem;
      background-color: #1f2937;
      border-left: 1px solid #374151;
      justify-content: center;
      gap: 1rem;
    }

    .action-btn {
      padding: 0.5rem;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
    }

    .action-btn:hover {
      transform: scale(1.1);
    }

    .action-btn svg {
      width: 20px;
      height: 20px;
    }

    .action-btn.positive {
      background-color: #10b981; /* Green */
      color: white;
    }

    .action-btn.positive:hover {
      background-color: #059669; /* Brighter green */
    }

    .action-btn.archive {
      background-color: #f59e0b; /* Yellow */
      color: white;
    }

    .action-btn.archive:hover {
      background-color: #d97706; /* Brighter yellow */
    }

    .action-btn.negative {
      background-color: #ef4444; /* Red */
      color: white;
    }

    .action-btn.negative:hover {
      background-color: #dc2626; /* Brighter red */
    }

    /* Modal styles for content popup */
    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    .modal-backdrop.active {
      opacity: 1;
      visibility: visible;
    }

    .modal-content {
      background-color: #1f2937;
      border-radius: 0.5rem;
      width: 90%;
      max-width: 900px;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      transform: scale(0.9);
      transition: transform 0.3s ease;
    }

    .modal-backdrop.active .modal-content {
      transform: scale(1);
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem;
      border-bottom: 1px solid #374151;
    }

    .modal-title {
      font-size: 1.2rem;
      font-weight: 500;
    }

    .modal-close {
      background: none;
      border: none;
      color: #9ca3af;
      cursor: pointer;
      padding: 0.5rem;
    }

    .modal-body {
      flex: 1;
      padding: 1rem;
      overflow-y: auto;
    }

    /* User info in modal */
    .user-info {
      display: flex;
      justify-content: space-between;
      padding: 0.5rem 0;
      font-size: 0.875rem;
      color: #9ca3af;
      margin-bottom: 0.5rem;
    }

    /* Conversation Tab */
    .conversation-item {
      margin-bottom: 1rem;
    }

    .conversation-item.user {
      text-align: right;
    }

    .conversation-item.assistant {
      text-align: left;
    }

    .conversation-bubble {
      display: inline-block;
      max-width: 80%;
      padding: 0.75rem;
      border-radius: 0.5rem;
      white-space: pre-line;
    }

    .conversation-item.user .conversation-bubble {
      background-color: #2563eb;
      color: white;
      border-top-right-radius: 0;
    }

    .conversation-item.assistant .conversation-bubble {
      background-color: #374151;
      color: white;
      border-top-left-radius: 0;
    }

    .conversation-role {
      font-size: 0.875rem;
      font-weight: 500;
      margin-bottom: 0.25rem;
      opacity: 0.7;
    }

    /* Suggestion and Cypher Query Tabs */
    .suggestion-list, .cypher-list {
      list-style-type: none;
      padding-left: 0;
    }

    .suggestion-list li, .cypher-list li {
      padding: 0.75rem;
      background-color: #374151;
      border-radius: 0.5rem;
      margin-bottom: 0.75rem;
      word-wrap: break-word;
      white-space: pre-wrap;
    }

    /* Tabs Navigation */
    .tabs-container {
      margin-bottom: 1rem;
    }

    .tabs-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }

    .tabs-list {
      display: flex;
      gap: 0.25rem;
      overflow-x: auto;
      scrollbar-width: thin;
      padding: 0.25rem 0;
      flex-grow: 1;
    }

    .tab-nav-btn {
      padding: 0.5rem 0.75rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: none;
      border-radius: 0.25rem;
      cursor: pointer;
      white-space: nowrap;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .tab-nav-btn:hover {
      background-color: #374151;
    }

    .tab-nav-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .pagination-btn {
      padding: 0.5rem 0.75rem;
      background-color: #1f2937;
      color: #d1d5db;
      border: none;
      border-radius: 0.25rem;
      cursor: pointer;
    }

    .pagination-btn.active {
      background-color: #2563eb;
      color: white;
    }

    /* No results */
    .no-results {
      text-align: center;
      padding: 2.5rem 0;
      color: #9ca3af;
    }
    /* Hide user info in modal */
    #modal-user-info {
      display: none;
    }

    /* Animations and keyframes */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .hidden {
      display: none;
    }

    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      color: #9ca3af;
    }

    .loading::before {
      content: "";
      width: 20px;
      height: 20px;
      margin-right: 10px;
      border-radius: 50%;
      border: 2px solid #9ca3af;
      border-top-color: #3b82f6;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Disabled controls styling */
    .sort-controls.disabled,
    .date-range-filter.disabled {
      opacity: 0.5;
      cursor: not-allowed;
      pointer-events: none;
    }
    
    .sort-controls.disabled span,
    .date-range-filter.disabled span,
    .date-range-filter.disabled label {
      color: #6b7280;
    }
    
    .sort-controls.disabled button,
    .date-range-filter.disabled button,
    .date-range-filter.disabled input {
      cursor: not-allowed;
      background-color: #374151;
      color: #6b7280;
    }
    
    /* Override pointer-events for tooltip functionality */
    .sort-controls.disabled,
    .date-range-filter.disabled {
      pointer-events: auto;
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Mürşit Feedback Sistemi</h1>
  <!-- QDrant Panel -->
  <div id="qdrant-panel" class="qdrant-panel">
    <h3>Add to QDrant</h3>
    <div class="schema-selector-container">
      <button id="mesai-option" class="schema-option-btn selected" data-schema="mesai">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="29" height="29" viewBox="0 0 29 29">
          <defs>
            <clipPath id="clip-path">
              <rect id="Rectangle_8976" data-name="Rectangle 8976" width="29" height="29" rx="5" transform="translate(-0.422 -0.329)" fill="#0d4150" stroke="#0d4150" stroke-width="12"/>
            </clipPath>
            <linearGradient id="linear-gradient" x1="0.5" x2="1.168" y2="1.46" gradientUnits="objectBoundingBox">
              <stop offset="0" stop-color="#0f2430"/>
              <stop offset="1" stop-color="#051e2c"/>
            </linearGradient>
            <clipPath id="clip-path-2">
              <rect id="Rectangle_8976-2" data-name="Rectangle 8976" width="29" height="29" rx="8" transform="translate(-0.422 -0.329)" fill="#0d4150" stroke="#0d4150" stroke-width="12"/>
            </clipPath>
            <clipPath id="clip-path-3">
              <rect id="Rectangle_30184" data-name="Rectangle 30184" width="29" height="29" rx="8" transform="translate(-0.422 -0.329)" fill="#adfd4f"/>
            </clipPath>
          </defs>
          <g id="mesai-logo" transform="translate(0.422 0.329)">
            <g id="Group_184126" data-name="Group 184126" transform="translate(0 0)">
              <g id="Group_11991" data-name="Group 11991" transform="translate(0 0)" style="isolation: isolate">
                <rect id="Rectangle_9176" data-name="Rectangle 9176" width="29" height="29" rx="5" transform="translate(-0.422 -0.329)" fill="url(#linear-gradient)"/>
              </g>
              <g id="Group_46636" data-name="Group 46636" transform="translate(0 0)">
                <g id="Mask_Group_441" data-name="Mask Group 441" clip-path="url(#clip-path-3)">
                  <g id="Group_46628" data-name="Group 46628" transform="translate(3.219 3.73)">
                    <g id="Group_46629" data-name="Group 46629">
                      <path id="Path_78116" data-name="Path 78116" d="M36.774,27.3a2.15,2.15,0,0,0,.032.313,1.048,1.048,0,0,0,.9.743,1.076,1.076,0,0,0,1.045-.571c.318-.521.616-1.055.919-1.585a1.086,1.086,0,0,0,.044-1,.931.931,0,0,0-.822-.584,1,1,0,0,0-1.032.5c-.324.543-.636,1.092-.947,1.643a.845.845,0,0,0-.137.549m-7.9-2.69a1.084,1.084,0,0,0-.316.037,1.072,1.072,0,0,0-.562,1.545c.3.546.619,1.084.937,1.621a1,1,0,0,0,.929.537,1.06,1.06,0,0,0,.882-1.635c-.254-.459-.531-.906-.783-1.366a1.142,1.142,0,0,0-1.086-.739m-.88,5.647a1.046,1.046,0,0,0-.566-1.022c-.519-.29-1.03-.593-1.542-.894a1.062,1.062,0,1,0-1.067,1.834c.53.3,1.051.613,1.58.914a1.048,1.048,0,0,0,1.056.029.89.89,0,0,0,.539-.861" transform="translate(-22.868 -23.25)" fill="#adfd4f"/>
                      <path id="Path_78117" data-name="Path 78117" d="M0,179.172a.09.09,0,0,0,.085-.078,1.029,1.029,0,0,1,1.066-.772c.611-.016,1.223-.01,1.835,0a1.056,1.056,0,0,1,1.027,1.463,1.13,1.13,0,0,1-1.005.667c-.626.007-1.252.017-1.877,0a1.018,1.018,0,0,1-1.045-.771A.09.09,0,0,0,0,179.6Z" transform="translate(0 -168.462)" fill="#adfd4f" opacity="0.2"/>
                      <path id="Path_78119" data-name="Path 78119" d="M180.3,0c.061.074.155.061.231.1a1.1,1.1,0,0,1,.61,1.041,17.536,17.536,0,0,1-.026,2.261,1.08,1.08,0,0,1-1.028.96,1.109,1.109,0,0,1-1.037-.946c-.048-.64.014-1.281-.032-1.918a1.334,1.334,0,0,1,.813-1.5Z" transform="translate(-169.126)" fill="#adfd4f"/>
                      <path id="Path_78122" data-name="Path 78122" d="M251.6,27.3a.845.845,0,0,1,.137-.549c.311-.55.624-1.1.947-1.643a1,1,0,0,1,1.032-.5.931.931,0,0,1,.822.584,1.086,1.086,0,0,1-.044,1c-.3.531-.6,1.064-.919,1.585a1.076,1.076,0,0,1-1.045.571,1.048,1.048,0,0,1-.9-.743,2.153,2.153,0,0,1-.032-.313" transform="translate(-237.698 -23.25)" fill="#adfd4f"/>
                      <path id="Path_78123" data-name="Path 78123" d="M27.913,45.087a1.04,1.04,0,0,0-1.565-.923c-.557.307-1.1.632-1.656.945a1.17,1.17,0,0,0-.5,1.155,1.064,1.064,0,0,0,1.584.661c.439-.272.9-.514,1.349-.766.424-.236.807-.5.784-1.073" transform="translate(-22.835 -30.17)" fill="#adfd4f" opacity="0.3"/>
                      <path id="Path_78124" data-name="Path 78124" d="M29.844,51.164a1.032,1.032,0,0,0,1.923.606c.338-.532.633-1.088.947-1.634a1.047,1.047,0,0,0,.119-.845.9.9,0,0,0-.788-.743.964.964,0,0,0-1.058.4c-.307.494-.594,1-.885,1.5a1.079,1.079,0,0,0-.257.713" transform="translate(-24.853 -31.769)" fill="#adfd4f" opacity="0.4"/>
                    </g>
                    <path id="Path_78133" data-name="Path 78133" d="M3.746,2.061A.993.993,0,0,0,3.259,1.1C2.69.749,2.107.423,1.516.112A1.064,1.064,0,0,0,.152.494,1.065,1.065,0,0,0,.507,1.942,14.656,14.656,0,0,0,2.754,3.07a1.018,1.018,0,0,0,.993-1.009" transform="translate(17.549 10.497) rotate(-30)" fill="#adfd4f" opacity="0.8"/>
                    <path id="Path_78134" data-name="Path 78134" d="M307.414,90.553a1.041,1.041,0,0,1-.56.971q-.812.477-1.633.938a1.057,1.057,0,0,1-1.421-1.439c.191-.355.542-.481.847-.672.371-.232.762-.431,1.136-.658a1.094,1.094,0,0,1,1.53.41.886.886,0,0,1,.1.45" transform="translate(-286.889 -84.588)" fill="#adfd4f" opacity="0.9"/>
                    <path id="Path_78135" data-name="Path 78135" d="M51.9,46.088a.993.993,0,0,0-.488-.962c-.568-.349-1.152-.675-1.742-.987a1.046,1.046,0,0,0-1.01,1.83A14.656,14.656,0,0,0,50.909,47.1a1.018,1.018,0,0,0,.993-1.009" transform="translate(-31.378 -30.166)" fill="#adfd4f" opacity="0.7"/>
                    <path id="Path_78136" data-name="Path 78136" d="M37.481,52.18h0q0,.512,0,1.024a1.038,1.038,0,0,0,1.286.964,1.055,1.055,0,0,0,.828-1.113c.02-.59.008-1.18,0-1.771a1.7,1.7,0,0,0-.06-.373,1.059,1.059,0,0,0-1.356-.7,1.084,1.084,0,0,0-.706.967c.023.333,0,.668,0,1" transform="translate(-27.573 -32.353)" fill="#adfd4f" opacity="0.5"/>
                    <path id="Path_78137" data-name="Path 78137" d="M44.715,48.538c-.113.016-.21,0-.31.026a1.054,1.054,0,0,0-.616,1.508c.313.565.633,1.128.968,1.681a1,1,0,0,0,.96.535,1.07,1.07,0,0,0,.838-1.634q-.444-.741-.858-1.5a1.063,1.063,0,0,0-.981-.616" transform="translate(-29.775 -31.773)" fill="#adfd4f" opacity="0.6"/>
                  </g>
                </g>
                <path id="Path_78130" data-name="Path 78130" d="M-11901.028-9878.131a.967.967,0,0,1-.682-.282l-1.329-1.328a.967.967,0,0,1,0-1.365.965.965,0,0,1,1.366,0l.645.645,2.54-2.539a.965.965,0,0,1,1.365,0,.964.964,0,0,1,0,1.365l-3.221,3.223A.97.97,0,0,1-11901.028-9878.131Z" transform="translate(11914.906 9895.346)" fill="none" stroke="#9ffd53" stroke-linecap="round" stroke-width="1"/>
              </g>
            </g>
          </g>
        </svg>

<!--        <span class="schema-label">Mesai</span>-->
      </button>

      <div class="schema-selector-divider"></div>

      <button id="mukavele-option" class="schema-option-btn" data-schema="mukavele">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="49" height="49" viewBox="0 0 49 49">
          <defs>
            <clipPath id="clip-path">
              <rect id="Rectangle_8976" data-name="Rectangle 8976" width="49" height="49" rx="8" fill="#0d4150" stroke="#0d4150" stroke-width="12"/>
            </clipPath>
            <filter id="Path_17571" x="9.084" y="-11.168" width="60.113" height="60.169" filterUnits="userSpaceOnUse">
              <feOffset input="SourceAlpha"/>
              <feGaussianBlur stdDeviation="7.5" result="blur"/>
              <feFlood flood-opacity="0.349"/>
              <feComposite operator="in" in2="blur"/>
              <feComposite in="SourceGraphic"/>
            </filter>
          </defs>
          <g id="Group_11327" data-name="Group 11327" transform="translate(-0.393 0)">
            <rect id="Rectangle_9176" data-name="Rectangle 9176" width="49" height="49" rx="8" transform="translate(0.393 0)" fill="#05323f"/>
            <g id="Group_10857" data-name="Group 10857" transform="translate(0.393 0)">
              <g id="Mask_Group_301" data-name="Mask Group 301" transform="translate(0 0)" clip-path="url(#clip-path)">
                <g id="Group_10608" data-name="Group 10608" transform="translate(-7.534 3.631)">
                  <path id="Path_17572" data-name="Path 17572" d="M5.261,5.263V49.188H36.354l-.121-37.269L29.7,5.837,5.261,5.263M3.5,0,29.237.034,41.614,12.559V50.948a3.5,3.5,0,0,1-3.5,3.5H3.5a3.5,3.5,0,0,1-3.5-3.5V3.5A3.5,3.5,0,0,1,3.5,0ZM41.614,12.307v.253C41.614,12.37,41.614,12.307,41.614,12.307Z" transform="matrix(0.966, 0.259, -0.259, 0.966, 14.092, 0)" fill="#3ffde4"/>
                  <g id="Group_10606" data-name="Group 10606" transform="matrix(0.966, 0.259, -0.259, 0.966, 16.898, 21.89)">
                    <path id="Path_17568" data-name="Path 17568" d="M23.9,1.944H.863A.923.923,0,0,1,0,.972.922.922,0,0,1,.863,0H23.9a.922.922,0,0,1,.863.972A.923.923,0,0,1,23.9,1.944Z" transform="translate(0 0)" fill="#3ffde4"/>
                    <path id="Path_17569" data-name="Path 17569" d="M23.9,1.944H.863A.923.923,0,0,1,0,.972.922.922,0,0,1,.863,0H23.9a.922.922,0,0,1,.863.972A.923.923,0,0,1,23.9,1.944Z" transform="translate(0 5.834)" fill="#3ffde4"/>
                    <path id="Path_17570" data-name="Path 17570" d="M13.953,1.944H.972A.972.972,0,1,1,.972,0h12.98a.972.972,0,1,1,0,1.944Z" transform="translate(0 11.668)" fill="#3ffde4"/>
                  </g>
                  <g transform="matrix(1, 0, 0, 1, 7.53, -3.63)" filter="url(#Path_17571)">
                    <path id="Path_17571-2" data-name="Path 17571" d="M.007,0,12.323,12.4h0L3.464,12.4A3.471,3.471,0,0,1,0,8.916L0,4.374Z" transform="matrix(0.97, 0.26, -0.26, 0.97, 34.79, 11.33)" fill="#3ffde4"/>
                  </g>
                </g>
              </g>
            </g>
          </g>
        </svg>
        <!--        <span class="schema-label">Mukavele</span>-->
      </button>
    </div>
    <div class="qdrant-input-group">
      <label for="qdrant-question">Question:</label>
      <textarea id="qdrant-question" placeholder="Enter question text..."></textarea>
    </div>
    <div class="qdrant-input-group">
      <label for="qdrant-cypher">Cypher Query:</label>
      <textarea id="qdrant-cypher" placeholder="Enter cypher query..."></textarea>
    </div>
    <button id="send-to-qdrant" class="qdrant-send-btn">Send to QDrant</button>
    </div>
  </div>

  <div class="qdrant-toggle-container">
    <button id="qdrant-toggle-btn" class="qdrant-toggle-btn">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="10"></circle>
        <line x1="12" y1="8" x2="12" y2="16"></line>
        <line x1="8" y1="12" x2="16" y2="12"></line>
      </svg>
      <span>Switch to QDrant View</span>
    </button>
  </div>

  <!-- Add container for QDrant view (initially hidden) -->
  <div id="qdrant-view-container" class="qdrant-view-container hidden">
    <h2>QDrant Vector Database</h2>
    <div class="qdrant-controls">
      <div class="qdrant-filter">
        <label for="qdrant-schema-filter">Filter by Schema:</label>
        <select id="qdrant-schema-filter" class="qdrant-select">
          <option value="">All Schemas</option>
          <option value="mesai">Mesai</option>
          <option value="mukavele">Mukavele</option>
          <option value="null">No Schema</option>
        </select>
      </div>
      <div class="qdrant-search">
        <input type="text" id="qdrant-search-input" placeholder="Search QDrant..." class="qdrant-input">
      </div>
    </div>
    <div id="qdrant-items-container" class="qdrant-items-container">
      <!-- QDrant items will be inserted here -->
    </div>
    <div id="qdrant-no-items" class="qdrant-no-items hidden">
      No QDrant data found.
    </div>
  </div>

  <!-- MongoDB Connection Status -->
  <div class="connection-status">
    <div id="connection-indicator" class="status-indicator"></div>
    <span id="connection-text">Connecting to MongoDB...</span>
  </div>

  <!-- Search Bar -->
  <div class="search-container">
    <svg class="search-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="11" cy="11" r="8"></circle>
      <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
    </svg>
    <input type="text" id="search-input" class="search-input" placeholder="Search questions or queries...">
  </div>

  <!-- Schema Filter Buttons -->
  <div class="filter-section">
    <div class="filter-label">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
      </svg>
      <span>Şema Filtreleri:</span>
    </div>
    <div id="schema-filters" class="filter-buttons">
      <button data-schema="Mesai" class="filter-btn">Mesai</button>
      <button data-schema="Mukavele" class="filter-btn">Mukavele</button>
      <button data-schema="Genel" class="filter-btn">Genel</button>
    </div>
  </div>

  <!-- Feedback Filter Buttons -->
  <div class="feedback-filters">
    <div class="filter-label">
      <span>Feedback Filtreleri:</span>
    </div>
    <button id="positive-filter" class="filter-btn">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
        <path d="M7 10v12"></path>
        <path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z"></path>
      </svg>
      Positive
    </button>
    <button id="negative-filter" class="filter-btn">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
        <path d="M17 14V2"></path>
        <path d="M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22h0a3.13 3.13 0 0 1-3-3.88Z"></path>
      </svg>
      Negative
    </button>
    <button id="hidden-filter" class="filter-btn">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
        <rect width="20" height="5" x="2" y="3" rx="1"></rect>
        <path d="M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8"></path>
        <path d="M10 12h4"></path>
      </svg>
      Show Archived
    </button>
  </div>

  <!-- Page Size Selection -->
  <div class="page-size">
    <span>Gösterilecek:</span>
    <button data-size="20" class="page-size-btn active">20</button>
    <button data-size="40" class="page-size-btn">40</button>
    <button data-size="100" class="page-size-btn">100</button>
    <button data-size="200" class="page-size-btn">200</button>
  </div>

  <!-- Date Sorting Controls -->
  <div class="sort-controls disabled" title="Disabled in the current release">
    <span>Sort by date:</span>
    <button id="sort-newest" class="sort-btn active" disabled title="Disabled in the current release">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="m3 16 4 4 4-4"/>
        <path d="M7 20V4"/>
        <path d="M11 4h10"/>
        <path d="M11 8h7"/>
        <path d="M11 12h4"/>
      </svg>
      Newest First
    </button>
    <button id="sort-oldest" class="sort-btn" disabled title="Disabled in the current release">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="m3 8 4-4 4 4"/>
        <path d="M7 4v16"/>
        <path d="M11 12h4"/>
        <path d="M11 16h7"/>
        <path d="M11 20h10"/>
      </svg>
      Oldest First
    </button>
  </div>
  <!-- Date Range Filter -->
  <div class="date-range-filter disabled" title="Disabled in the current release">
    <span>Filter by time:</span>
    <div class="date-inputs">
      <div class="date-input-group">
        <label for="date-from">From:</label>
        <input type="date" id="date-from" class="date-input" disabled title="Disabled in the current release">
      </div>
      <div class="date-input-group">
        <label for="date-to">To:</label>
        <input type="date" id="date-to" class="date-input" disabled title="Disabled in the current release">
      </div>
    </div>
    <button id="apply-date-filter" class="filter-btn" disabled title="Disabled in the current release">Apply</button>
    <button id="clear-date-filter" class="filter-btn" disabled title="Disabled in the current release">Clear</button>
  </div>

  <!-- Tabs Navigation -->
  <div id="tabs-container" class="tabs-container">
    <div class="tabs-header">
      <button id="prev-tab-btn" class="tab-nav-btn">&laquo; Previous</button>
      <div id="tabs-list" class="tabs-list"></div>
      <button id="next-tab-btn" class="tab-nav-btn">Next &raquo;</button>
    </div>
  </div>

  <!-- Results count -->
  <div id="results-count" class="results-count"></div>

  <!-- Feedback Items -->
  <div id="feedback-items" class="feedback-items"></div>

  <!-- No results message -->
  <div id="no-results" class="no-results hidden">
    No questions found matching your criteria
  </div>
</div>

<!-- Modal for viewing feedback content -->
<div id="feedback-modal" class="modal-backdrop">
  <div class="modal-content">
    <div class="modal-header">
      <div class="modal-title" id="modal-title">Feedback Details</div>
      <button class="modal-close" id="modal-close">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      </button>
    </div>
    <div class="user-info" id="modal-user-info">
      <span id="modal-username">User: username</span>
      <span id="modal-datetime">Date: YYYY-MM-DD HH:MM</span>
    </div>
    <div class="modal-body" id="modal-body">
      <!-- Content will be dynamically inserted here -->
    </div>
  </div>
</div>

<script>
  // MongoDB API config
  const API_BASE_URL = "http://localhost:3000/api"; // Change this to your deployed API URL in production

  // App state
  let data = [];
  let filteredData = [];
  let activeSchema = null;
  let activeFeedbackFilter = null;
  let showHidden = false;
  //let pageSize = 20;
  let searchQuery = '';
  let currentItemId = null;
  let schemaList = ["Mesai", "Mukavele", "Genel"];
  let currentPage = 0;
  let totalPages = 0;
  let visibleTabCount = 5; // Number of tabs to show at once
  let sortOrder = 'newest'; // 'newest' or 'oldest'
  let dateFrom = null;
  let dateTo = null;
  let isQdrantMode = false;
  let qdrantData = [];
  let filteredQdrantData = [];

  // Add these global variables near the top of your script (around line 400)
  // This ensures that any code trying to access these variables won't cause reference errors

  // Default value for activeTypeFilter
  window.activeTypeFilter = null;

  // Dummy function for filterByType
  window.filterByType = function(type) {
    console.log('Type filtering is disabled, ignoring request to filter by:', type);
    return false;
  };

  // Dummy function for initializeTypeFilters
  window.initializeTypeFilters = function() {
    console.log('Type filters initialization skipped (feature disabled)');
    return false;
  };

  // Remove the type filters section from DOM
  document.addEventListener('DOMContentLoaded', function() {
    // Find and remove type filters container if it exists
    const typeFiltersSection = document.querySelector('.filter-section:has(#type-filters)');
    if (typeFiltersSection) {
      console.log('Removing type filters section from DOM');
      typeFiltersSection.remove();
    }

    // Or just the inner element
    const typeFilters = document.getElementById('type-filters');
    if (typeFilters) {
      console.log('Removing type filters element from DOM');
      typeFilters.remove();
    }
  });

  // Modify applyFilters to skip type filtering
  // This is a patch to be applied to the original function
  const originalApplyFilters = window.applyFilters;
  if (typeof originalApplyFilters === 'function') {
    window.applyFilters = function() {
      // Access safe variables
      window.activeTypeFilter = window.activeTypeFilter || null;

      // Call original with wrapped try/catch
      try {
        return originalApplyFilters.apply(this, arguments);
      } catch (error) {
        console.error('Error in applyFilters:', error);

        // Fallback implementation
        let filtered = [...data];

        // Apply schema filter if active
        if (activeSchema) {
          filtered = filtered.filter(item => item.schema === activeSchema);
        }

        // Apply feedback filter if active
        if (activeFeedbackFilter) {
          filtered = filtered.filter(item => item.feedback === activeFeedbackFilter);
        }

        // Apply hidden filter
        if (!showHidden) {
          filtered = filtered.filter(item => !item.hidden);
        }

        // Apply search query
        if (searchQuery) {
          filtered = filtered.filter(item =>
                  (item.question && item.question.toLowerCase().includes(searchQuery)) ||
                  (item.user && item.user.toLowerCase().includes(searchQuery))
          );
        }

        filteredData = filtered;
        renderItems();
      }
    };
  }

  // Remove type filters references from fix scripts
  function patchExternalScripts() {
    // Create a MutationObserver to watch for script additions
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList') {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeName === 'SCRIPT' && node.src) {
              // For pagination-fix.js
              if (node.src.includes('pagination-fix.js')) {
                console.log('Patching pagination-fix.js...');
                setTimeout(() => {
                  // Safe access to window.applyFilters
                  const originalApplyFilters = window.applyFilters;
                  if (typeof originalApplyFilters === 'function') {
                    window.applyFilters = function() {
                      try {
                        // Ensure activeTypeFilter exists
                        window.activeTypeFilter = window.activeTypeFilter || null;
                        return originalApplyFilters.apply(this, arguments);
                      } catch (error) {
                        console.error('Error in patched applyFilters:', error);
                      }
                    };
                  }
                }, 200);
              }
            }
          });
        }
      });
    });

    // Start observing
    observer.observe(document.documentElement, { childList: true, subtree: true });

    // Return the observer to stop it later if needed
    return observer;
  }

  // Call the patching function after a delay
  setTimeout(patchExternalScripts, 100);

  function getElement(id, create = false) {
    let element = document.getElementById(id);

    if (!element && create) {
      console.log(`Creating missing element with ID: ${id}`);
      element = document.createElement('div');
      element.id = id;

      // Style and append depending on the element type
      switch(id) {
        case 'connection-indicator':
          element.className = 'status-indicator';
          const connectionStatus = document.querySelector('.connection-status');
          if (connectionStatus) {
            connectionStatus.appendChild(element);
          } else {
            // Create connection status container if needed
            const container = document.createElement('div');
            container.className = 'connection-status';
            container.appendChild(element);

            // Add connection text element
            const connectionText = document.createElement('span');
            connectionText.id = 'connection-text';
            connectionText.textContent = 'Connecting to MongoDB...';
            container.appendChild(connectionText);

            // Insert at the top of the container
            const mainContainer = document.querySelector('.container');
            if (mainContainer && mainContainer.firstChild) {
              mainContainer.insertBefore(container, mainContainer.firstChild.nextSibling);
            } else {
              document.body.appendChild(container);
            }
          }
          break;

        case 'connection-text':
          element.textContent = 'Connecting to MongoDB...';
          const statusIndicator = document.querySelector('.connection-status');
          if (statusIndicator) {
            statusIndicator.appendChild(element);
          } else {
            document.body.appendChild(element);
          }
          break;

          // Insert after schema filters
          const schemaFilters = document.getElementById('schema-filters');
          if (schemaFilters) {
            const parentNode = schemaFilters.parentNode;
            if (parentNode) {
              parentNode.insertBefore(element, schemaFilters.nextSibling);
            }
          } else {
            document.body.appendChild(element);
          }
          break;

        case 'dialog-content':
          element.className = 'modal-body';

          // Find modal or create one
          const modal = document.getElementById('feedback-modal');
          if (modal) {
            const modalContent = modal.querySelector('.modal-content');
            if (modalContent) {
              modalContent.appendChild(element);
            } else {
              modal.appendChild(element);
            }
          } else {
            document.body.appendChild(element);
          }
          break;

        case 'tabs-list':
          element.className = 'tabs-list';

          // Find tabs container
          const tabsContainer = document.getElementById('tabs-container');
          if (tabsContainer) {
            const tabsHeader = tabsContainer.querySelector('.tabs-header');
            if (tabsHeader) {
              // Find the proper position to insert
              const prevBtn = document.getElementById('prev-tab-btn');
              if (prevBtn && prevBtn.nextSibling) {
                tabsHeader.insertBefore(element, prevBtn.nextSibling);
              } else {
                tabsHeader.appendChild(element);
              }
            } else {
              tabsContainer.appendChild(element);
            }
          } else {
            document.body.appendChild(element);
          }
          break;

        default:
          // Default case, just append to body
          document.body.appendChild(element);
      }
    }

    return element || {
      // Return a dummy element if still not found and not created
      classList: { add: () => {}, remove: () => {}, toggle: () => {}, contains: () => false },
      textContent: '',
      innerHTML: '',
      appendChild: () => {},
      style: {}
    };
  }

  async function fetchQdrantData() {
    try {
      const connectionIndicator = getElement('connection-indicator', true);
      const connectionText = getElement('connection-text', true);

      connectionText.textContent = 'Fetching QDrant data...';

      const queryParams = new URLSearchParams();
      queryParams.append('limit', 500); // Fetch a larger number for QDrant view

      // Apply schema filter if selected
      const schemaFilter = document.getElementById('qdrant-schema-filter');
      if (schemaFilter) {
        // Always send the schema parameter, even if empty
        // This ensures null/empty handling on the backend
        console.log(`Schema filter value: "${schemaFilter.value}"`);
        queryParams.append('schema', schemaFilter.value);
      }

      const apiUrl = `${API_BASE_URL}/qdrant/data?${queryParams.toString()}`;
      console.log(`Fetching QDrant data from: ${apiUrl}`);

      const response = await fetch(apiUrl);

      if (!response.ok) {
        throw new Error(`API responded with status: ${response.status}`);
      }

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error || 'Unknown error');
      }

      console.log(`Received ${result.data.length} records from QDrant`);
      connectionText.textContent = `Found ${result.data.length} records in QDrant`;

      // Store the QDrant data
      qdrantData = result.data;
      filteredQdrantData = [...qdrantData];

      return qdrantData;
    } catch (error) {
      console.error('Error fetching QDrant data:', error);
      connectionText.textContent = 'Failed to fetch QDrant data: ' + error.message;
      return [];
    }
  }

  // Add this function to filter QDrant data
  function filterQdrantData() {
    // Start with all data
    let filtered = [...qdrantData];

    // Apply schema filter
    const schemaFilter = document.getElementById('qdrant-schema-filter');
    if (schemaFilter) {
      const schemaValue = schemaFilter.value;
      console.log(`Filtering by schema: "${schemaValue}"`);

      if (schemaValue) {
        // Case-insensitive schema comparison
        filtered = filtered.filter(item => {
          // Handle null schemas
          if (schemaValue === 'null') {
            return !item.schema || item.schema === '';
          }

          // Case-insensitive match
          return item.schema && item.schema.toLowerCase() === schemaValue.toLowerCase();
        });
      }
    }

    // Apply search filter
    const searchInput = document.getElementById('qdrant-search-input');
    if (searchInput && searchInput.value.trim() !== '') {
      const searchQuery = searchInput.value.trim().toLowerCase();
      filtered = filtered.filter(item => {
        const matchesMessage = item.message && item.message.toLowerCase().includes(searchQuery);
        const matchesCypher = item.cypher && item.cypher.toLowerCase().includes(searchQuery);
        const matchesSchema = item.schema && item.schema.toLowerCase().includes(searchQuery);
        const matchesGroupId = item.groupId && item.groupId.toLowerCase().includes(searchQuery);

        return matchesMessage || matchesCypher || matchesSchema || matchesGroupId;
      });
    }

    console.log(`Filtering resulted in ${filtered.length} items`);

    // Update filtered data
    filteredQdrantData = filtered;

    // Render QDrant items
    renderQdrantItems();
  }

  // Add this function to render QDrant items
  function renderQdrantItems() {
    const container = document.getElementById('qdrant-items-container');
    const noItems = document.getElementById('qdrant-no-items');

    if (!container || !noItems) return;

    // Clear container
    container.innerHTML = '';

    // Show no items message if no data
    if (filteredQdrantData.length === 0) {
      noItems.classList.remove('hidden');
      return;
    }

    // Hide no items message
    noItems.classList.add('hidden');

    // Render items
    filteredQdrantData.forEach(item => {
      // Create item element
      const itemElement = document.createElement('div');
      itemElement.className = 'qdrant-item';

      // Create header
      const header = document.createElement('div');
      header.className = 'qdrant-item-header';
      header.innerHTML = `
      <span class="qdrant-item-schema">${item.schema || 'No Schema'}</span>
      <span class="qdrant-item-group">${item.groupId || 'No Group'}</span>
    `;

      // Create body
      const body = document.createElement('div');
      body.className = 'qdrant-item-body';

      // Add message
      const message = document.createElement('div');
      message.className = 'qdrant-item-message';
      message.textContent = item.message || 'No message';

      // Add cypher query
      const cypher = document.createElement('div');
      cypher.className = 'qdrant-item-cypher';
      cypher.textContent = item.cypher || 'No Cypher query';

      // Add version
      const version = document.createElement('div');
      version.className = 'qdrant-item-version';
      version.textContent = `Version: ${item.bot_version || 'Unknown'}`;

      // Assemble item
      body.appendChild(message);
      body.appendChild(cypher);
      body.appendChild(version);

      itemElement.appendChild(header);
      itemElement.appendChild(body);

      // Add to container
      container.appendChild(itemElement);
    });
  }

  // Add this function to toggle QDrant view mode
  function toggleQdrantMode() {
    const container = document.querySelector('.container');
    const toggleButton = document.getElementById('qdrant-toggle-btn');
    const qdrantContainer = document.getElementById('qdrant-view-container');

    if (!container || !toggleButton || !qdrantContainer) return;

    // Toggle mode
    isQdrantMode = !isQdrantMode;

    if (isQdrantMode) {
      // Switch to QDrant mode
      container.classList.add('qdrant-mode');
      toggleButton.classList.add('active');
      toggleButton.querySelector('span').textContent = 'Switch to Feedback View';
      qdrantContainer.classList.remove('hidden');

      // Fetch QDrant data if not already loaded
      if (qdrantData.length === 0) {
        fetchQdrantData().then(() => {
          renderQdrantItems();
        });
      } else {
        // Use existing data
        renderQdrantItems();
      }
    } else {
      // Switch back to regular mode
      container.classList.remove('qdrant-mode');
      toggleButton.classList.remove('active');
      toggleButton.querySelector('span').textContent = 'Switch to QDrant View';
      qdrantContainer.classList.add('hidden');

      // Make sure regular data is displayed
      renderItems();
    }
  }

  // Function to format date in a user-friendly way
  function formatDateTime(dateStr) {
    if (/\d{1,2}\/\d{1,2}\/\d{4}, \d{1,2}:\d{2}:\d{2}/.test(dateStr)) {
      return dateStr;
    }

    let date;

    if (typeof dateStr === 'string') {
      if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(dateStr)) {
        date = new Date(dateStr);
      } else if (/^\d{10}$/.test(dateStr)) {
        date = new Date(parseInt(dateStr) * 1000); // seconds
      } else if (/^\d{13}$/.test(dateStr)) {
        date = new Date(parseInt(dateStr)); // milliseconds
      } else {
        date = new Date(dateStr); // fallback
      }
    } else if (typeof dateStr === 'number') {
      if (dateStr < 1e12) {
        date = new Date(dateStr * 1000); // number in seconds
      } else {
        date = new Date(dateStr); // number in milliseconds
      }
    } else if (dateStr instanceof Date) {
      date = dateStr;
    } else {
      return "Invalid date";
    }

    if (isNaN(date.getTime())) {
      return "Invalid date";
    }

    const options = {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false,
      timeZone: 'UTC' // optional, depends on if you want local or UTC
    };

    return date.toLocaleString(undefined, options);
  }
  // Helper function to render formatted content with better HTML handling
  function renderFormattedContent(text) {
    if (!text) return '';

    if (text.includes('<') && text.includes('>')) {
      return text;
    }

    let formattedText = text.replace(/\n/g, '<br>');

    formattedText = formattedText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    formattedText = formattedText.replace(/__(.*?)__/g, '<strong>$1</strong>');

    if (formattedText.includes('|')) {
      const lines = formattedText.split('<br>');
      let inTable = false;
      let tableContent = '';
      let processedLines = [];

      for (let line of lines) {
        if (line.trim().startsWith('|') && line.trim().endsWith('|')) {
          if (!inTable) {
            inTable = true;
            tableContent = '<table class="conversation-table">';
          }

          const cells = line.split('|').filter(cell => cell.trim() !== '');
          tableContent += '<tr>';
          cells.forEach(cell => {
            tableContent += `<td>${cell.trim()}</td>`;
          });
          tableContent += '</tr>';
        } else {
          if (inTable) {
            tableContent += '</table>';
            processedLines.push(tableContent);
            inTable = false;
            tableContent = '';
          }
          processedLines.push(line);
        }
      }

      if (inTable) {
        tableContent += '</table>';
        processedLines.push(tableContent);
      }

      formattedText = processedLines.join('<br>');
    }

    return formattedText;
  }

  // Update the conversation modal function
  function openConversationModal(item) {
    currentItemId = item.id;

    document.getElementById('modal-title').textContent = "Conversation";
    document.getElementById('modal-username').textContent = `User: ${item.user}`;
    document.getElementById('modal-datetime').textContent = `Date: ${formatDateTime(item.datetime)}`;

    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = '';

    if (item.conversation && item.conversation.length > 0) {
      item.conversation.forEach(message => {
        const messageElement = document.createElement('div');
        messageElement.className = `conversation-item ${message.role}`;

        const formattedMessage = renderFormattedContent(message.message);

        messageElement.innerHTML = `
        <div class="conversation-bubble">
          <p class="conversation-role">${message.role === 'user' ? 'User' : 'Assistant'}</p>
          <div class="conversation-content">${formattedMessage}</div>
        </div>
      `;
        modalBody.appendChild(messageElement);
      });
    } else {
      modalBody.innerHTML = '<p>No conversation available</p>';
    }

    const modal = document.getElementById('feedback-modal');
    modal.classList.add('active');
  }

  // Update the suggestion modal function
  function openSuggestionModal(item) {
    currentItemId = item.id;

    document.getElementById('modal-title').textContent = "Suggestions";
    document.getElementById('modal-username').textContent = `User: ${item.user}`;
    document.getElementById('modal-datetime').textContent = `Date: ${formatDateTime(item.datetime)}`;

    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = '';

    const suggestionList = document.createElement('ul');
    suggestionList.className = 'suggestion-list';

    if (item.suggestions && item.suggestions.length > 0) {
      item.suggestions.forEach(suggestion => {
        const li = document.createElement('li');
        li.innerHTML = renderFormattedContent(suggestion);
        suggestionList.appendChild(li);
      });
    } else {
      const li = document.createElement('li');
      li.textContent = 'No suggestions available';
      suggestionList.appendChild(li);
    }

    modalBody.appendChild(suggestionList);

    const modal = document.getElementById('feedback-modal');
    modal.classList.add('active');
  }

  // Update the cypher query modal function
  function openCypherModal(item) {
    currentItemId = item.id;

    document.getElementById('modal-title').textContent = "Cypher Query";
    document.getElementById('modal-username').textContent = `User: ${item.user}`;
    document.getElementById('modal-datetime').textContent = `Date: ${formatDateTime(item.datetime)}`;

    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = '';

    const cypherContainer = document.createElement('div');
    cypherContainer.className = 'cypher-container';

    if (item.cypherQueries && item.cypherQueries.length > 0) {
      item.cypherQueries.forEach(query => {
        const queryElement = document.createElement('div');
        queryElement.className = 'cypher-query';
        queryElement.innerHTML = renderFormattedContent(query);
        cypherContainer.appendChild(queryElement);
      });
    } else {
      const noQueryElement = document.createElement('div');
      noQueryElement.textContent = 'No Cypher queries available';
      cypherContainer.appendChild(noQueryElement);
    }

    modalBody.appendChild(cypherContainer);

    const modal = document.getElementById('feedback-modal');
    modal.classList.add('active');
  }

  // Load or initialize DOM elements
  document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM fully loaded, initializing application...');

    // Create critical elements first
    getElement('connection-indicator', true);
    getElement('connection-text', true);
    getElement('type-filters', true);
    getElement('dialog-content', true);
    getElement('tabs-list', true);

    // Create schema buttons if they don't exist
    const schemaFilters = getElement('schema-filters', true);
    if (!schemaFilters.querySelector('.filter-btn')) {
      console.log('No schema buttons found, creating them...');
      schemaList.forEach(schema => {
        const button = document.createElement('button');
        button.className = 'filter-btn';
        button.dataset.schema = schema;
        button.textContent = schema;
        button.addEventListener('click', () => filterBySchema(schema));
        schemaFilters.appendChild(button);
      });
    }
    // Set up QDrant toggle button
    const toggleButton = document.getElementById('qdrant-toggle-btn');
    if (toggleButton) {
      toggleButton.addEventListener('click', toggleQdrantMode);
    }

    // Set up QDrant filter controls
    const schemaFilter = document.getElementById('qdrant-schema-filter');
    if (schemaFilter) {
      schemaFilter.addEventListener('change', function() {
        if (isQdrantMode) {
          if (this.value) {
            // If a schema is selected, filter the existing data
            filterQdrantData();
          } else {
            // If "All Schemas" is selected, fetch all data again
            fetchQdrantData().then(() => {
              renderQdrantItems();
            });
          }
        }
      });
    }

    // Set up QDrant search
    const searchInput = document.getElementById('qdrant-search-input');
    if (searchInput) {
      searchInput.addEventListener('input', function() {
        if (isQdrantMode) {
          filterQdrantData();
        }
      });
    }


    // Initialize other UI elements
    // const searchInput = getElement('search-input');
    const schemaFilterButtons = document.querySelectorAll('#schema-filters .filter-btn');
    const positiveFilter = getElement('positive-filter');
    const negativeFilter = getElement('negative-filter');
    const hiddenFilter = getElement('hidden-filter');
    const pageSizeButtons = document.querySelectorAll('.page-size-btn');
    const resultsCount = getElement('results-count', true);
    const feedbackItems = getElement('feedback-items', true);
    const noResults = getElement('no-results', true);

    // Setup event listeners
    searchInput.addEventListener('input', () => {
      searchQuery = searchInput.value.toLowerCase();
      applyFilters();
    });

    // Setup schema buttons (already done above)

    // Feedback filter event listeners
    if (positiveFilter) {
      positiveFilter.addEventListener('click', () => {
        if (activeFeedbackFilter === 'positive') {
          activeFeedbackFilter = null;
          positiveFilter.classList.remove('active');
        } else {
          activeFeedbackFilter = 'positive';
          positiveFilter.classList.add('active');
          negativeFilter.classList.remove('active');
        }
        applyFilters();
      });
    }

    if (negativeFilter) {
      negativeFilter.addEventListener('click', () => {
        if (activeFeedbackFilter === 'negative') {
          activeFeedbackFilter = null;
          negativeFilter.classList.remove('active');
        } else {
          activeFeedbackFilter = 'negative';
          negativeFilter.classList.add('active');
          positiveFilter.classList.remove('active');
        }
        applyFilters();
      });
    }

    // Toggle hidden items
    if (hiddenFilter) {
      hiddenFilter.addEventListener('click', () => {
        showHidden = !showHidden;
        hiddenFilter.classList.toggle('active', showHidden);

        if (showHidden) {
          hiddenFilter.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
            <rect width="20" height="5" x="2" y="3" rx="1"></rect>
            <path d="M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8"></path>
            <path d="M10 12h4"></path>
          </svg>
          Hide Archived
        `;
        } else {
          hiddenFilter.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline; margin-right: 4px;">
            <rect width="20" height="5" x="2" y="3" rx="1"></rect>
            <path d="M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8"></path>
            <path d="M10 12h4"></path>
          </svg>
          Show Archived
        `;
        }
        applyFilters();
      });
    }

    // Page size buttons
    pageSizeButtons.forEach(button => {
      button.addEventListener('click', () => {
        pageSizeButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        pageSize = parseInt(button.dataset.size);
        renderItems();
      });
    });

    // Modal close button
    const modal = getElement('feedback-modal');
    const modalClose = getElement('modal-close');

    if (modalClose) {
      modalClose.addEventListener('click', () => {
        closeModal();
      });
    }

    // Close modal when clicking outside
    if (modal) {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          closeModal();
        }
      });
    }

    // Initialize with MongoDB connection after a short delay
    setTimeout(() => {
      console.log('Initializing MongoDB connection...');
      try {
        connectToMongoDB();
      } catch (error) {
        console.error('Error during initial MongoDB connection:', error);
        // Show error on the page
        const connectionText = getElement('connection-text', true);
        connectionText.textContent = 'Error connecting to MongoDB: ' + error.message;
      }
    }, 100);
  });

  function openConversationModal(item) {
    currentItemId = item.id;

    document.getElementById('modal-title').textContent = "Conversation";
    document.getElementById('modal-username').textContent = `User: ${item.user}`;
    document.getElementById('modal-datetime').textContent = `Date: ${formatDateTime(item.datetime)}`;

    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = '';

    if (item.conversation && item.conversation.length > 0) {
      item.conversation.forEach(message => {
        const messageElement = document.createElement('div');
        messageElement.className = `conversation-item ${message.role}`;

        const formattedMessage = renderFormattedContent(message.message);

        messageElement.innerHTML = `
        <div class="conversation-bubble">
          <p class="conversation-role">${message.role === 'user' ? 'User' : 'Assistant'}</p>
          <div class="conversation-content">${formattedMessage}</div>
        </div>
      `;
        modalBody.appendChild(messageElement);
      });
    } else {
      modalBody.innerHTML = '<p>No conversation available</p>';
    }

    const modal = document.getElementById('feedback-modal');
    modal.classList.add('active');
  }

  function openSuggestionModal(item) {
    currentItemId = item.id;

    document.getElementById('modal-title').textContent = "Suggestion";
    document.getElementById('modal-username').textContent = `User: ${item.user}`;
    document.getElementById('modal-datetime').textContent = `Date: ${formatDateTime(item.datetime)}`;

    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = '';

    const suggestionList = document.createElement('ul');
    suggestionList.className = 'suggestion-list';

    if (item.suggestions && item.suggestions.length > 0) {
      item.suggestions.forEach(suggestion => {
        const li = document.createElement('li');
        li.textContent = suggestion;
        suggestionList.appendChild(li);
      });
    } else {
      const li = document.createElement('li');
      li.textContent = 'No suggestions available';
      suggestionList.appendChild(li);
    }

    modalBody.appendChild(suggestionList);

    const modal = document.getElementById('feedback-modal');
    modal.classList.add('active');
  }

  function openCypherModal(item) {
    currentItemId = item.id;

    document.getElementById('modal-title').textContent = "Cypher Query";
    document.getElementById('modal-username').textContent = `User: ${item.user}`;
    document.getElementById('modal-datetime').textContent = `Date: ${formatDateTime(item.datetime)}`;

    const modalBody = document.getElementById('modal-body');
    modalBody.innerHTML = '';

    const cypherList = document.createElement('ul');
    cypherList.className = 'cypher-list';

    if (item.cypherQueries && item.cypherQueries.length > 0) {
      item.cypherQueries.forEach(query => {
        const li = document.createElement('li');
        li.textContent = query;
        cypherList.appendChild(li);
      });
    } else {
      const li = document.createElement('li');
      li.textContent = 'No Cypher queries available';
      cypherList.appendChild(li);
    }

    modalBody.appendChild(cypherList);

    const modal = document.getElementById('feedback-modal');
    modal.classList.add('active');
  }

  function closeModal() {
    const modal = document.getElementById('feedback-modal');
    modal.classList.remove('active');
    currentItemId = null;
  }

  function convertMongoDataToAppFormat(mongoData) {
    if (!mongoData || !Array.isArray(mongoData)) {
      console.error("Invalid MongoDB data:", mongoData);
      return [];
    }

    try {
      return mongoData.map(item => {
        try {
          console.log("Processing item:", item);

          let parsedMessages = parseMessages(item.messages || "[]");

          const firstUserMessage = parsedMessages.length > 0 ?
                  parsedMessages.find(msg => msg.role === 'user') : null;
          const question = firstUserMessage ? firstUserMessage.message : 'No question found';

          let suggestions = [];
          try {
            if (item.entitySuggesterData && item.entitySuggesterData !== "[]") {
              console.log("Processing entitySuggesterData:", item.entitySuggesterData);

              if (typeof item.entitySuggesterData === 'string') {
                const cleanedData = item.entitySuggesterData
                        .replace(/=/g, ':')
                        .replace(/'/g, '"');

                try {
                  const parsedData = JSON.parse(cleanedData);

                  if (Array.isArray(parsedData)) {
                    parsedData.forEach(entry => {
                      if (entry && entry.suggestion && entry.suggestion !== 'null') {
                        suggestions.push(entry.suggestion);
                      } else if (entry && entry.text && entry.text !== 'null') {
                        suggestions.push(entry.text);
                      } else if (entry && typeof entry === 'string') {
                        suggestions.push(entry);
                      }
                    });
                  }
                } catch (jsonError) {
                  console.warn("Error parsing entitySuggesterData as JSON", jsonError);

                  const suggestionMatches = item.entitySuggesterData.match(/suggestion=([^,}]+)/g);
                  if (suggestionMatches) {
                    suggestionMatches.forEach(match => {
                      const value = match.replace('suggestion=', '').trim();
                      if (value && value !== 'null') {
                        suggestions.push(value);
                      }
                    });
                  }
                }
              }
            }
          } catch (suggErr) {
            console.warn("Error processing suggestions:", suggErr);
          }

          let cypherQueries = [];
          if (item.sql_query) {
            if (typeof item.sql_query === 'string' && item.sql_query.trim() !== '') {
              cypherQueries = [item.sql_query];
            }
          } else {
            try {
              if (item.agentHistoryFilteredData && item.agentHistoryFilteredData.includes('content=MATCH')) {
                const match = item.agentHistoryFilteredData.match(/content=(MATCH[^}]+)/);
                if (match && match[1]) {
                  cypherQueries = [match[1].trim()];
                }
              }
            } catch (queryErr) {
              console.warn("Error extracting query from history:", queryErr);
            }
          }

          let timestamp;
          if (item.timestamp) {
            timestamp = typeof item.timestamp === 'number' ?
                    item.timestamp :
                    (typeof item.timestamp === 'string' ? parseInt(item.timestamp) : null);
          } else if (item.RDate && item.RDate.$date) {
            timestamp = new Date(item.RDate.$date).getTime();
          } else {
            timestamp = Date.now();
          }
          
          // Fix for Unix timestamps in seconds format
          if (timestamp > 1000000000 && timestamp < 2000000000) {
            console.log(`Converting Unix timestamp from seconds to ms: ${timestamp} → ${timestamp * 1000}`);
            timestamp = timestamp * 1000;
          }
          
          // Fix timestamp if it's in seconds instead of milliseconds
          timestamp = fixTimestamp(timestamp);

          const date = new Date(timestamp);
          const formattedDate = isNaN(date.getTime()) ? 'Invalid date' :
                  date.toLocaleDateString() + ' ' + date.toLocaleTimeString();

          const id = item._id?.$oid ||
                  (typeof item._id === 'string' ? item._id : null) ||
                  item.uuid ||
                  `temp-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

          const hasAgentHistoryData = Boolean(item.agentHistoryFilteredData) &&
                  item.agentHistoryFilteredData !== "[]" &&
                  item.agentHistoryFilteredData !== undefined &&
                  String(item.agentHistoryFilteredData).length > 2;

          const hasContractIds = Boolean(item.contract_ids) &&
                  item.contract_ids !== "[]" &&
                  item.contract_ids !== undefined &&
                  String(item.contract_ids).length > 2;

          const hasDocumentIds = Boolean(item.document_ids) &&
                  item.document_ids !== "[]" &&
                  item.document_ids !== undefined &&
                  String(item.document_ids).length > 2;

          const hasEntitySuggesterData = Boolean(item.entitySuggesterData) &&
                  item.entitySuggesterData !== "[]" &&
                  item.entitySuggesterData !== undefined &&
                  String(item.entitySuggesterData).length > 2;

          return {
            id: id,
            schema: item.schema || '',
            question: question,
            conversation: parsedMessages,
            suggestions: suggestions,
            cypherQueries: cypherQueries,
            feedback: item.feedback || null,
            hidden: item.hidden || false,
            user: item.userName || 'Unknown',
            datetime: formattedDate,
            timestamp: timestamp,
            agentHistoryFilteredData: item.agentHistoryFilteredData || "[]",
            contractIds: item.contract_ids || "[]",
            documentIds: item.document_ids || "[]",
            entitySuggesterData: item.entitySuggesterData || "[]",
            hasAgentHistoryData: hasAgentHistoryData,
            hasContractIds: hasContractIds,
            hasDocumentIds: hasDocumentIds,
            hasEntitySuggesterData: hasEntitySuggesterData
          };
        } catch (itemError) {
          console.error("Error converting item:", itemError, item);
          return null;
        }
      }).filter(Boolean);
    } catch (error) {
      console.error("Error converting MongoDB data:", error);
      return [];
    }
  }

  function parseMessages(messagesString) {
    try {
      console.log("Parsing messages:", messagesString);

      if (!messagesString) {
        console.warn('Messages is null or undefined');
        return [
          { role: 'user', message: 'No messages available' }
        ];
      }

      if (typeof messagesString !== 'string') {
        console.warn('Messages is not a string:', messagesString);
        return [
          { role: 'user', message: 'Message parsing error' },
          { role: 'assistant', message: 'Unable to parse messages' }
        ];
      }

      if (messagesString.includes('role=') && messagesString.includes('content=')) {
        try {
          let cleanedString = messagesString
                  .replace(/^\[|\]$/g, '')
                  .replace(/\}\s*,\s*\{/g, '}|||{');

          const messageParts = cleanedString.split('|||');

          return messageParts.map(part => {
            const roleMatch = part.match(/role=([^,}]+)/);
            const role = roleMatch ? roleMatch[1].trim() : 'unknown';

            const contentMatch = part.match(/content=(.*?)(?=\s*,\s*\w+=|\s*\}|\s*$)/s);
            let message = contentMatch ? contentMatch[1].trim() : 'No content';

            if (message.startsWith('"') && !message.endsWith('"') && !message.endsWith('"}')) {
              message += '"';
            }

            message = message.replace(/^\{|\}$/g, '').trim();
            message = message.replace(/^"|"$/g, '').trim();

            return { role, message };
          });
        } catch (formatError) {
          console.error("Error parsing new message format:", formatError);
        }
      }

      try {
        const parsedJson = JSON.parse(messagesString);
        if (Array.isArray(parsedJson)) {
          return parsedJson.map(msg => ({
            role: msg.role || 'unknown',
            message: msg.content || 'No content'
          }));
        }
      } catch (jsonError) {
        console.warn("JSON parsing failed:", jsonError.message);
      }

      try {
        let jsonLikeString = messagesString
                .replace(/([a-zA-Z]+)=/g, '"$1":')
                .replace(/'/g, '"');

        const parsedJson = JSON.parse(jsonLikeString);
        if (Array.isArray(parsedJson)) {
          return parsedJson.map(msg => ({
            role: msg.role || 'unknown',
            message: msg.content || 'No content'
          }));
        }
      } catch (jsonError2) {
        console.warn('Failed with replacements too:', jsonError2.message);
      }

      try {
        const matches = messagesString.match(/\{role=(.*?), content=(.*?)(\},|\}$)/gs);
        if (matches && matches.length > 0) {
          return matches.map(match => {
            const roleMatch = match.match(/role=(.*?),/);
            const contentMatch = match.match(/content=(.*?)(\},|\}$)/s);

            return {
              role: roleMatch ? roleMatch[1].trim() : 'unknown',
              message: contentMatch ? contentMatch[1].trim() : 'Error parsing message'
            };
          });
        }
      } catch (regexError) {
        console.warn('Regex parsing failed:', regexError.message);
      }

      console.warn("Using fallback parsing for:", messagesString.substring(0, 50) + "...");
      return [
        { role: 'user', message: 'Error parsing message' },
        { role: 'assistant', message: 'Error parsing message' }
      ];
    } catch (error) {
      console.error("Critical error parsing messages:", error);
      return [
        { role: 'user', message: 'Error parsing message' },
        { role: 'assistant', message: 'Error parsing message' }
      ];
    }
  }

  async function connectToMongoDB(page = 0) {
    try {
      // Fix for Unix timestamps in seconds format
      if (!isNaN(dateStr)) {
        // Convert to number if it's a string
        const timestamp = Number(dateStr);
        
        // Unix timestamps from 2023-2030 in seconds format are roughly between 1700000000-1900000000
        // In milliseconds, they would be 1700000000000-1900000000000
        if (timestamp > 1000000000 && timestamp < 2000000000) {
          console.log(`Converting Unix timestamp from seconds to ms: ${timestamp} → ${timestamp * 1000}`);
          dateStr = timestamp * 1000;
        }
      }
      
      connectionIndicator.classList.remove('connected');
      connectionIndicator.classList.remove('disconnected');
      connectionText.textContent = `Connecting to MongoDB (page ${page + 1})...`;

      // Get elements safely
      const connectionIndicator = getElement('connection-indicator', true);
      const connectionText = getElement('connection-text', true);

      data = [];
      filteredData = [];

      const response = await fetch(`${API_BASE_URL}/conversations?page=${page}&limit=${pageSize}`);

      if (!response.ok) {
        throw new Error(`API responded with status: ${response.status}`);
      }

      const result = await response.json();
      console.log("API response:", result);

      let mongoData;
      if (result.data) {
        mongoData = result.data;

        currentPage = result.pagination.page;
        totalPages = result.pagination.totalPages;
      } else {
        mongoData = result;
        currentPage = 0;
        totalPages = 1;
      }

      connectionIndicator.classList.add('connected');
      connectionText.textContent = `Connected to MongoDB - ${mongoData.length} records loaded`;

      if (result.pagination) {
        connectionText.textContent += ` (Page ${currentPage + 1} of ${totalPages} - Total: ${result.pagination.totalCount})`;
      }

      data = convertMongoDataToAppFormat(mongoData);
      console.log("Converted data:", data);

      filteredData = [...data.filter(item => !item.hidden)];

      console.log("API response received:", result);
      console.log("Converted data length:", data.length);
      console.log("First item:", data[0]);

      initializeTabs(totalPages);

      renderItems();

    } catch (error) {
      console.error('Error connecting to MongoDB:', error);
      connectionIndicator.classList.add('disconnected');
      connectionText.textContent = 'Failed to connect to MongoDB: ' + error.message;
    }
  }

  function initializeTabs(totalPages) {
    const tabsList = document.getElementById('tabs-list');
    const prevTabBtn = document.getElementById('prev-tab-btn');
    const nextTabBtn = document.getElementById('next-tab-btn');

    if (!tabsList || !prevTabBtn || !nextTabBtn) return;

    tabsList.innerHTML = '';

    for (let i = 0; i < totalPages; i++) {
      const tab = document.createElement('button');
      tab.className = `pagination-btn${currentPage === i ? ' active' : ''}`;
      tab.textContent = `Page ${i + 1}`;
      tab.dataset.page = i;

      tab.addEventListener('click', () => {
        if (currentPage !== i) {
          loadPage(i);
        }
      });

      tabsList.appendChild(tab);
    }

    updateTabsVisibility();

    prevTabBtn.disabled = currentPage === 0;
    nextTabBtn.disabled = currentPage === totalPages - 1;

    prevTabBtn.addEventListener('click', () => {
      if (currentPage > 0) {
        loadPage(currentPage - 1);
      }
    });

    nextTabBtn.addEventListener('click', () => {
      if (currentPage < totalPages - 1) {
        loadPage(currentPage + 1);
      }
    });
  }

  async function loadPage(page) {
    connectionText.textContent = `Loading page ${page + 1}...`;

    try {
      const response = await fetch(`${API_BASE_URL}/conversations?page=${page}&limit=${pageSize}`);

      if (!response.ok) {
        throw new Error(`API responded with status: ${response.status}`);
      }

      const result = await response.json();
      const mongoData = result.data;

      currentPage = page;

      data = convertMongoDataToAppFormat(mongoData);
      filteredData = [...data.filter(item => !item.hidden)];

      const tabButtons = document.querySelectorAll('.pagination-btn');
      tabButtons.forEach(tab => {
        const tabPage = parseInt(tab.dataset.page);
        tab.classList.toggle('active', tabPage === currentPage);
      });

      updateTabsVisibility();

      document.getElementById('prev-tab-btn').disabled = currentPage === 0;
      document.getElementById('next-tab-btn').disabled = currentPage === totalPages - 1;

      connectionText.textContent = `Page ${currentPage + 1} of ${totalPages} - Total records: ${result.pagination.totalCount}`;

      renderItems();

    } catch (error) {
      console.error('Error loading page:', error);
      connectionText.textContent = `Failed to load page ${page + 1}: ${error.message}`;
    }
  }

  function updateTabsVisibility() {
    const tabButtons = document.querySelectorAll('.pagination-btn');

    let startIndex = Math.max(0, currentPage - Math.floor(visibleTabCount / 2));
    let endIndex = Math.min(totalPages - 1, startIndex + visibleTabCount - 1);

    if (endIndex - startIndex + 1 < visibleTabCount) {
      startIndex = Math.max(0, endIndex - visibleTabCount + 1);
    }

    tabButtons.forEach((tab, index) => {
      tab.style.display = (index >= startIndex && index <= endIndex) ? 'block' : 'none';
    });
  }

  // Fix for schema buttons detection (add after the getElement function, around line 480)

  // Function to ensure schema buttons exist
  function ensureSchemaButtonsExist() {
    console.log('Checking and ensuring schema buttons exist...');

    // Get the schema filters container
    const schemaFilters = getElement('schema-filters', true);

    // Check if schema buttons already exist
    const existingButtons = schemaFilters.querySelectorAll('.filter-btn[data-schema]');

    if (existingButtons.length === 0) {
      console.log('No schema buttons found, creating them...');

      // Create schema buttons
      schemaList.forEach(schema => {
        const button = document.createElement('button');
        button.className = 'filter-btn';
        button.dataset.schema = schema;
        button.textContent = schema;

        // Add event listener for schema filtering
        button.addEventListener('click', () => {
          filterBySchema(schema);
        });

        // Add to container
        schemaFilters.appendChild(button);
      });

      console.log(`Created ${schemaList.length} schema buttons`);
    } else {
      console.log(`Found ${existingButtons.length} existing schema buttons`);
    }
  }

  // Call this function early to ensure buttons exist
  document.addEventListener('DOMContentLoaded', function() {
    // Execute with short delay to ensure DOM is ready
    setTimeout(ensureSchemaButtonsExist, 100);

    // Also patch the feedback-system-fixes.js detection
    window.addEventListener('load', function() {
      // Suppress the schema buttons warning by overriding console.error
      const originalConsoleError = console.error;
      console.error = function(...args) {
        // Check if this is the specific error we want to suppress
        if (args[0] === 'No schema buttons found. This might cause reference errors.') {
          console.warn('Suppressed schema buttons warning, buttons will be created');
          // Create buttons if they don't exist
          ensureSchemaButtonsExist();
        } else {
          // Pass through to original console.error
          originalConsoleError.apply(console, args);
        }
      };

      // Restore original after a delay
      setTimeout(() => {
        console.error = originalConsoleError;
      }, 2000);
    });
  });


  // Add this fix near the top of your script (around line 390, before most other code)

  // Global proxy for connectionIndicator and connectionText
  (function() {
    // Create global accessor for connection elements
    Object.defineProperty(window, 'connectionIndicator', {
      get: function() {
        const element = document.getElementById('connection-indicator');
        if (!element) {
          console.warn('Accessing undefined connectionIndicator, creating on demand');
          // Create the element on demand
          const newElement = document.createElement('div');
          newElement.id = 'connection-indicator';
          newElement.className = 'status-indicator';

          // Find connection status container or create it
          let container = document.querySelector('.connection-status');
          if (!container) {
            container = document.createElement('div');
            container.className = 'connection-status';
            document.body.insertBefore(container, document.body.firstChild);
          }

          container.appendChild(newElement);
          return newElement;
        }
        return element;
      },
      configurable: true
    });

    Object.defineProperty(window, 'connectionText', {
      get: function() {
        const element = document.getElementById('connection-text');
        if (!element) {
          console.warn('Accessing undefined connectionText, creating on demand');
          // Create the element on demand
          const newElement = document.createElement('span');
          newElement.id = 'connection-text';
          newElement.textContent = 'Connecting to MongoDB...';

          // Find connection status container or create it
          let container = document.querySelector('.connection-status');
          if (!container) {
            container = document.createElement('div');
            container.className = 'connection-status';
            document.body.insertBefore(container, document.body.firstChild);
          }

          container.appendChild(newElement);
          return newElement;
        }
        return element;
      },
      configurable: true
    });

    // Connect to MongoDB function wrapper
    const originalConnectToMongoDB = window.connectToMongoDB;
    window.connectToMongoDB = function(page = 0) {
      try {
        // Make sure variables are defined
        const connectionIndicator = window.connectionIndicator;
        const connectionText = window.connectionText;

        // Call original if exists
        if (typeof originalConnectToMongoDB === 'function') {
          return originalConnectToMongoDB(page);
        } else {
          console.error('Original connectToMongoDB function not found');
          connectionText.textContent = 'Error: MongoDB connection function not found';
          return Promise.reject(new Error('MongoDB connection function not found'));
        }
      } catch (error) {
        console.error('Error in connectToMongoDB wrapper:', error);
        return Promise.reject(error);
      }
    };
  })();

  // Add a patch for pagination-fix.js's connectToMongoDB function
  document.addEventListener('DOMContentLoaded', function() {
    // Create a MutationObserver to watch for script tags
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type !== 'childList') continue;

        for (const node of mutation.addedNodes) {
          if (node.nodeName !== 'SCRIPT') continue;

          // Check if this is pagination-fix.js
          if (node.src && node.src.includes('pagination-fix.js')) {
            console.log('Detected pagination-fix.js loading, preparing patch...');

            // Wait for script to load and execute
            node.addEventListener('load', () => {
              console.log('Patching pagination-fix.js...');

              // Store original connectToMongoDB if it exists at this point
              const originalConnectToMongoDB = window.connectToMongoDB;

              // Define a new safe version
              window.connectToMongoDB = function(page = 0) {
                try {
                  console.log('Safe connectToMongoDB called from pagination-fix.js');

                  // Ensure we have connection elements
                  const connectionIndicator = window.connectionIndicator;
                  const connectionText = window.connectionText;

                  // Show connecting status safely
                  if (connectionIndicator && connectionIndicator.classList) {
                    connectionIndicator.classList.remove('connected');
                    connectionIndicator.classList.remove('disconnected');
                  }

                  if (connectionText) {
                    connectionText.textContent = `Connecting to MongoDB (page ${page + 1})...`;
                  }

                  // Call original if it exists
                  if (typeof originalConnectToMongoDB === 'function') {
                    return originalConnectToMongoDB(page);
                  } else {
                    console.error('Original connectToMongoDB function not found after patching');
                    if (connectionText) {
                      connectionText.textContent = 'Error: MongoDB connection function not found';
                    }
                  }
                } catch (error) {
                  console.error('Error in patched connectToMongoDB:', error);
                }
              };
            });
          }
        }
      }
    });

    // Start observing document for script additions
    observer.observe(document, { childList: true, subtree: true });

    // Disconnect after a reasonable timeout
    setTimeout(() => observer.disconnect(), 10000);
  });

  // Add this patch after the global variables declaration (around line 420)

  // Patch for pagination-fix.js to handle missing activeTypeFilter
  document.addEventListener('DOMContentLoaded', function() {
    // Ensure activeTypeFilter is defined
    window.activeTypeFilter = null;

    // Patch the applyFilters function to handle missing type filter
    const patchApplyFilters = function() {
      // Get original function
      const originalApplyFilters = window.applyFilters;

      if (typeof originalApplyFilters === 'function') {
        console.log('Patching applyFilters function to handle missing typeFilter...');

        window.applyFilters = async function() {
          try {
            // Build query parameters for server-side filtering
            const queryParams = new URLSearchParams();

            // Add page and limit
            queryParams.append('page', window.currentPage || 0);
            queryParams.append('limit', window.pageSize || 20);

            // Add active filters
            if (window.activeSchema) {
              queryParams.append('schema', window.activeSchema);
            }

            // PATCH: Skip type filter if not defined
            // Original code:
            // if (activeTypeFilter) {
            //   queryParams.append('type', activeTypeFilter);
            // }

            // Instead use global variable or default to null
            if (window.activeTypeFilter) {
              queryParams.append('type', window.activeTypeFilter);
            }

            // Continue with rest of function...
            if (window.activeFeedbackFilter) {
              queryParams.append('feedback', window.activeFeedbackFilter);
            }

            // Add hidden filter
            queryParams.append('hidden', window.showHidden || false);

            // Add search query
            if (window.searchQuery) {
              queryParams.append('search', window.searchQuery);
            }

            // Call original function if exists
            return originalApplyFilters.apply(this, arguments);
          } catch (error) {
            console.error('Error in patched applyFilters:', error);

            // Fallback to client-side filtering
            console.log('Falling back to client-side filtering...');

            // Only client-side filter the current page data
            let filtered = [...window.data];

            // Apply schema filter if active
            if (window.activeSchema) {
              filtered = filtered.filter(item => item.schema === window.activeSchema);
            }

            // Apply feedback filter if active
            if (window.activeFeedbackFilter) {
              filtered = filtered.filter(item => item.feedback === window.activeFeedbackFilter);
            }

            // Apply hidden filter
            if (!window.showHidden) {
              filtered = filtered.filter(item => !item.hidden);
            }

            // Apply search query
            if (window.searchQuery) {
              filtered = filtered.filter(item =>
                      (item.question && item.question.toLowerCase().includes(window.searchQuery)) ||
                      (item.query && item.query.toLowerCase().includes(window.searchQuery))
              );
            }

            window.filteredData = filtered;
            window.renderItems();
          }
        };
      }
    };

    // Execute patch immediately
    patchApplyFilters();

    // Also patch on window load to ensure it runs after all scripts
    window.addEventListener('load', patchApplyFilters);

    // Patch for continuous-loading-fix.js
    const patchContinuousLoadingFix = function() {
      // Make sure optimizeFilterApplication function is safe
      if (typeof window.optimizeFilterApplication === 'function') {
        console.log('Patching optimizeFilterApplication function...');

        const originalOptimizeFilterApplication = window.optimizeFilterApplication;

        window.optimizeFilterApplication = function() {
          try {
            // Ensure activeTypeFilter exists
            window.activeTypeFilter = window.activeTypeFilter || null;

            // Call original
            return originalOptimizeFilterApplication.apply(this, arguments);
          } catch (error) {
            console.error('Error in patched optimizeFilterApplication:', error);
          }
        };
      }
    };

    // Patch for continuous loading fix
    setTimeout(patchContinuousLoadingFix, 1000);
  });


  function filterBySchema(schema) {
    const button = document.querySelector(`.filter-btn[data-schema="${schema}"]`);

    if (!button) return;

    if (activeSchema === schema) {
      activeSchema = null;
      button.classList.remove('active');
    } else {
      document.querySelectorAll('.filter-btn[data-schema]').forEach(btn => {
        btn.classList.remove('active');
      });

      activeSchema = schema;
      button.classList.add('active');
    }

    applyFilters();
  }

  function applyFilters() {
    console.log("Starting filter application with:", {
      activeSchema,
      activeFeedbackFilter,
      showHidden,
      searchQuery
    });

    // Start with full data
    let filtered = [...data];

    // Apply schema filter if active
    if (activeSchema) {
      console.log(`Filtering by schema: ${activeSchema}`);
      filtered = filtered.filter(item => item.schema === activeSchema);
    }

    // Apply feedback filter if active
    if (activeFeedbackFilter) {
      console.log(`Filtering by feedback: ${activeFeedbackFilter}`);
      filtered = filtered.filter(item => item.feedback === activeFeedbackFilter);
    }

    // Apply hidden filter
    if (!showHidden) {
      console.log('Filtering out hidden items');
      filtered = filtered.filter(item => !item.hidden);
    }

    // Apply search query
    if (searchQuery) {
      console.log(`Filtering by search query: ${searchQuery}`);
      filtered = filtered.filter(item =>
              (item.question && item.question.toLowerCase().includes(searchQuery)) ||
              (item.conversation && item.conversation.some(msg =>
                      msg.message.toLowerCase().includes(searchQuery)
              )) ||
              (item.user && item.user.toLowerCase().includes(searchQuery))
      );
    }

    console.log(`Filter result: ${filtered.length} items remaining`);
    filteredData = filtered;
    renderItems();
  }

  function renderItems() {
    const feedbackItems = document.getElementById('feedback-items');
    const noResults = document.getElementById('no-results');
    const resultsCount = document.getElementById('results-count');

    console.log("Rendering items, filtered data length:", filteredData.length);

    if (!feedbackItems || !noResults || !resultsCount) return;

    resultsCount.textContent = `Showing ${Math.min(pageSize, filteredData.length)} of ${filteredData.length} results`;

    feedbackItems.innerHTML = '';

    if (filteredData.length === 0) {
      noResults.classList.remove('hidden');
    } else {
      noResults.classList.add('hidden');

      filteredData.slice(0, pageSize).forEach((item, index) => {
        const itemElement = document.createElement('div');
        itemElement.className = 'feedback-item';
        itemElement.dataset.id = item.id;

        const schemaButtons = document.createElement('div');
        schemaButtons.className = 'schema-buttons';

        schemaList.forEach(schema => {
          const button = document.createElement('button');
          button.className = `schema-btn${item.schema === schema ? ' active' : ''}`;
          button.textContent = schema;
          button.dataset.schema = schema;

          button.addEventListener('click', (e) => {
            e.stopPropagation();
            setSchema(item.id, schema);
          });

          schemaButtons.appendChild(button);
        });

        const contentArea = document.createElement('div');
        contentArea.className = 'feedback-content';

        const userInfo = document.createElement('div');
        userInfo.className = 'feedback-user-info';
        userInfo.innerHTML = `
          <span class="user-name">User: ${item.user}</span>
          <span class="datetime">${formatDateTime(item.datetime)}</span>
        `;
        contentArea.appendChild(userInfo);

        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'feedback-buttons';

        const conversationBtn = document.createElement('button');
        conversationBtn.className = 'conversation-btn';
        conversationBtn.textContent = item.question;
        conversationBtn.addEventListener('click', () => {
          openConversationModal(item);
        });

        const smallButtons = document.createElement('div');
        smallButtons.className = 'small-buttons';

        const suggestionBtn = document.createElement('button');
        suggestionBtn.className = 'suggestion-btn';
        suggestionBtn.textContent = 'Suggestion';
        suggestionBtn.addEventListener('click', () => {
          openSuggestionModal(item);
        });

        const cypherBtn = document.createElement('button');
        cypherBtn.className = 'cypher-btn';
        cypherBtn.textContent = 'Cypher Query';
        cypherBtn.addEventListener('click', () => {
          openCypherModal(item);
        });

        smallButtons.appendChild(suggestionBtn);
        smallButtons.appendChild(cypherBtn);

        buttonsContainer.appendChild(conversationBtn);
        buttonsContainer.appendChild(smallButtons);

        contentArea.appendChild(buttonsContainer);

        const additionalDataButtons = document.createElement('div');
        additionalDataButtons.className = 'additional-data-buttons';

        const agentHistoryBtn = document.createElement('button');
        agentHistoryBtn.className = 'data-btn agent-history-btn';
        agentHistoryBtn.disabled = !item.hasAgentHistoryData;
        agentHistoryBtn.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 8c-2.8 0-5 2.2-5 5s2.2 5 5 5 5-2.2 5-5-2.2-5-5-5Z"></path>
            <path d="M3 12c0-5.5 5.9-10 9-10"></path>
            <path d="M15 2v6h6"></path>
            <path d="M21 12c0 5.5-5.9 10-9 10"></path>
            <path d="M9 22v-6H3"></path>
          </svg>
          Agent History
        `;
        agentHistoryBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (item.hasAgentHistoryData) {
            openDataPopup('Agent History', item.agentHistoryFilteredData);
          }
        });

        const contractIdsBtn = document.createElement('button');
        contractIdsBtn.className = 'data-btn contract-ids-btn';
        contractIdsBtn.disabled = !item.hasContractIds;
        contractIdsBtn.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M14 3v4a1 1 0 0 0 1 1h4"></path>
            <path d="M17 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2Z"></path>
            <path d="M9 9h1"></path>
            <path d="M9 13h6"></path>
            <path d="M9 17h6"></path>
          </svg>
          Contract IDs
        `;
        contractIdsBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (item.hasContractIds) {
            openDataPopup('Contract IDs', item.contractIds);
          }
        });

        // Create document IDs button
        const documentIdsBtn = document.createElement('button');
        documentIdsBtn.className = 'data-btn document-ids-btn';
        documentIdsBtn.disabled = !item.hasDocumentIds;
        documentIdsBtn.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
            <polyline points="14 2 14 8 20 8"></polyline>
            <line x1="16" y1="13" x2="8" y2="13"></line>
            <line x1="16" y1="17" x2="8" y2="17"></line>
            <polyline points="10 9 9 9 8 9"></polyline>
          </svg>
          Document IDs
        `;
        documentIdsBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (item.hasDocumentIds) {
            openDataPopup('Document IDs', item.documentIds);
          }
        });

        // Create entity suggester button
        const entitySuggesterBtn = document.createElement('button');
        entitySuggesterBtn.className = 'data-btn entity-suggester-btn';
        entitySuggesterBtn.disabled = !item.hasEntitySuggesterData;
        entitySuggesterBtn.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
          </svg>
          Entity Data
        `;
        entitySuggesterBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (item.hasEntitySuggesterData) {
            openDataPopup('Entity Suggester Data', item.entitySuggesterData);
          }
        });

        // Add buttons to container
        additionalDataButtons.appendChild(agentHistoryBtn);
        additionalDataButtons.appendChild(contractIdsBtn);
        additionalDataButtons.appendChild(documentIdsBtn);
        additionalDataButtons.appendChild(entitySuggesterBtn);

        // Add additional data buttons to the content area
        contentArea.appendChild(additionalDataButtons);

        // Create the actions column
        const actions = document.createElement('div');
        actions.className = 'feedback-actions';

        // Positive button (thumbs up)
        const positiveBtn = document.createElement('button');
        positiveBtn.className = `action-btn positive${item.feedback === 'positive' ? ' active' : ''}`;
        positiveBtn.dataset.action = 'positive';
        positiveBtn.innerHTML = `
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M7 10v12"></path>
            <path d="M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2h0a3.13 3.13 0 0 1 3 3.88Z"></path>
          </svg>
        `;

        positiveBtn.addEventListener('click', (e) => {
          e.stopPropagation(); // Don't open the modal
          handlePositiveFeedback(item.id);
        });

        // Archive button (now in middle position)
        const archiveBtn = document.createElement('button');
        archiveBtn.className = `action-btn archive${item.hidden ? ' active' : ''}`;
        archiveBtn.dataset.action = 'archive';
        archiveBtn.innerHTML = `
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect width="20" height="5" x="2" y="3" rx="1"></rect>
            <path d="M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8"></path>
            <path d="M10 12h4"></path>
          </svg>
        `;

        archiveBtn.addEventListener('click', (e) => {
          e.stopPropagation(); // Don't open the modal
          handleToggleHidden(item.id);
        });

        // Negative button (thumbs down) - now last
        const negativeBtn = document.createElement('button');
        negativeBtn.className = `action-btn negative${item.feedback === 'negative' ? ' active' : ''}`;
        negativeBtn.dataset.action = 'negative';
        negativeBtn.innerHTML = `
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M17 14V2"></path>
            <path d="M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22h0a3.13 3.13 0 0 1-3-3.88Z"></path>
          </svg>
        `;

        negativeBtn.addEventListener('click', (e) => {
          e.stopPropagation(); // Don't open the modal
          handleNegativeFeedback(item.id);
        });

        // Add action buttons to actions container in the new order
        actions.appendChild(positiveBtn);
        actions.appendChild(archiveBtn);
        actions.appendChild(negativeBtn);

        // Add all parts to the item
        itemElement.appendChild(schemaButtons);
        itemElement.appendChild(contentArea);
        itemElement.appendChild(actions);

        // Add to the container
        feedbackItems.appendChild(itemElement);
      });
    }
  }

  // Create a popup for displaying additional data
  function openDataPopup(title, data) {
    // Check if a popup already exists and remove it
    const existingPopup = document.getElementById('data-popup');
    if (existingPopup) {
      existingPopup.remove();
    }

    // Create popup container
    const popup = document.createElement('div');
    popup.id = 'data-popup';
    popup.className = 'data-popup';
    popup.setAttribute('role', 'dialog');
    popup.setAttribute('aria-labelledby', 'popup-title');
    popup.setAttribute('aria-modal', 'true');

    // Create popup content
    const popupContent = document.createElement('div');
    popupContent.className = 'popup-content';

    // Create header
    const popupHeader = document.createElement('div');
    popupHeader.className = 'popup-header';

    // Create title
    const popupTitle = document.createElement('h3');
    popupTitle.id = 'popup-title';
    popupTitle.textContent = title;
    popupHeader.appendChild(popupTitle);

    // Create button container for header
    const headerButtons = document.createElement('div');
    headerButtons.className = 'popup-header-buttons';

    // Create copy button
    const copyButton = document.createElement('button');
    copyButton.className = 'popup-copy';
    copyButton.title = 'Copy to clipboard';
    copyButton.innerHTML = `
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
    </svg>
  `;
    copyButton.addEventListener('click', () => {
      let textToCopy = typeof data === 'object' ? JSON.stringify(data, null, 2) : data;
      navigator.clipboard.writeText(textToCopy)
              .then(() => {
                copyButton.classList.add('success');
                setTimeout(() => copyButton.classList.remove('success'), 1500);
              })
              .catch(err => console.error('Failed to copy: ', err));
    });
    headerButtons.appendChild(copyButton);

    // Create close button
    const closeButton = document.createElement('button');
    closeButton.className = 'popup-close';
    closeButton.title = 'Close';
    closeButton.setAttribute('aria-label', 'Close');
    closeButton.innerHTML = `
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <line x1="18" y1="6" x2="6" y2="18"></line>
      <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
  `;
    closeButton.addEventListener('click', () => closePopup(popup));
    headerButtons.appendChild(closeButton);

    popupHeader.appendChild(headerButtons);
    popupContent.appendChild(popupHeader);

    // Create body
    const popupBody = document.createElement('div');
    popupBody.className = 'popup-body';

    // Format and add the data
    let formattedData;
    try {
      // Handle if data is already an object
      if (typeof data === 'object' && data !== null) {
        formattedData = `<pre>${JSON.stringify(data, null, 2)}</pre>`;
      }
      // Try to parse JSON if it's a string
      else if (typeof data === 'string') {
        try {
          const parsedData = JSON.parse(data);
          formattedData = `<pre>${JSON.stringify(parsedData, null, 2)}</pre>`;
        } catch {
          // If not valid JSON, display as formatted text
          formattedData = `<pre>${data}</pre>`;
        }
      } else {
        formattedData = `<pre>${String(data)}</pre>`;
      }
    } catch (e) {
      formattedData = `<pre>Error displaying data: ${e.message}</pre>`;
    }

    popupBody.innerHTML = formattedData;
    popupContent.appendChild(popupBody);

    // Add content to popup
    popup.appendChild(popupContent);

    // Add popup to body
    document.body.appendChild(popup);

    // Trap focus in modal for accessibility
    const focusableElements = popup.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    const firstElement = focusableElements[0];
    if (firstElement) firstElement.focus();

    // Animate the popup
    setTimeout(() => popup.classList.add('active'), 10);

    // Close popup function
    function closePopup(element) {
      element.classList.remove('active');
      setTimeout(() => element.remove(), 300);
    }

    // Add click outside to close
    popup.addEventListener('click', (e) => {
      if (e.target === popup) closePopup(popup);
    });

    // Add escape key to close
    const escapeHandler = (e) => {
      if (e.key === 'Escape') {
        closePopup(popup);
        document.removeEventListener('keydown', escapeHandler);
      }
    };
    document.addEventListener('keydown', escapeHandler);
  }

  // Handle positive feedback
  async function handlePositiveFeedback(id) {
    const item = data.find(item => item.id === id);
    if (!item) {
      console.error(`Item with id ${id} not found`);
      return;
    }

    // If already positive, remove feedback
    const newFeedback = item.feedback === 'positive' ? null : 'positive';
    console.log(`Setting feedback for ${id} to ${newFeedback}`);

    // Update data locally first
    data = data.map(dataItem => {
      if (dataItem.id === id) {
        return { ...dataItem, feedback: newFeedback };
      }
      return dataItem;
    });

    // Update UI
    const itemElement = document.querySelector(`.feedback-item[data-id="${id}"]`);
    if (itemElement) {
      // Update feedback buttons
      const positiveBtn = itemElement.querySelector('.action-btn.positive');
      if (positiveBtn) {
        positiveBtn.style.backgroundColor = newFeedback === 'positive' ? '#10b981' : '#374151';
      }

      const negativeBtn = itemElement.querySelector('.action-btn.negative');
      if (negativeBtn && newFeedback === 'positive') {
        negativeBtn.style.backgroundColor = '#374151';
      }

      // Update item class
      if (newFeedback === 'positive') {
        itemElement.classList.add('positive');
        itemElement.classList.remove('negative');
      } else {
        itemElement.classList.remove('positive');
      }
    }

    // Update MongoDB via API
    try {
      const response = await fetch(`${API_BASE_URL}/conversations/${id}/feedback`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ feedback: newFeedback })
      });

      if (!response.ok) {
        console.error('Error updating feedback:', await response.text());
      } else if (newFeedback === 'positive') {
        // Show QDrant confirmation dialog
        showQdrantConfirmDialog(item);
      }
    } catch (error) {
      console.error('Failed to update feedback:', error);
    }

    // Don't call applyFilters here - it resets the UI
    // Instead, update just this element's styles
  }

  // Handle negative feedback
  async function handleNegativeFeedback(id) {
    const item = data.find(item => item.id === id);
    if (!item) return;

    // If already negative, remove feedback
    const newFeedback = item.feedback === 'negative' ? null : 'negative';

    // Update data locally first
    data = data.map(item => {
      if (item.id === id) {
        return { ...item, feedback: newFeedback };
      }
      return item;
    });

    // Update MongoDB via API
    try {
      const response = await fetch(`${API_BASE_URL}/conversations/${id}/feedback`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ feedback: newFeedback })
      });

      if (!response.ok) {
        console.error('Error updating feedback:', await response.text());
      }
    } catch (error) {
      console.error('Failed to update feedback:', error);
    }

    // Apply filters to update UI
    applyFilters();
  }

  // Handle toggle hidden
  async function handleToggleHidden(id) {
    const item = data.find(item => item.id === id);
    if (!item) return;

    // Toggle hidden state
    const newHiddenState = !item.hidden;

    // Update data locally first
    data = data.map(item => {
      if (item.id === id) {
        return { ...item, hidden: newHiddenState };
      }
      return item;
    });

    // Update MongoDB via API
    try {
      const response = await fetch(`${API_BASE_URL}/conversations/${id}/archive`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ hidden: newHiddenState })
      });

      if (!response.ok) {
        console.error('Error updating archive status:', await response.text());
      }
    } catch (error) {
      console.error('Failed to update archive status:', error);
    }

    // Apply filters to update UI
    applyFilters();
  }

  // Set schema for an item
  async function setSchema(id, schema) {
    const item = data.find(item => item.id === id);
    if (!item) return;

    // Update schema locally first
    const oldSchema = item.schema;
    item.schema = schema;

    // Update schema buttons in this item
    const itemElement = document.querySelector(`.feedback-item[data-id="${id}"]`);
    if (itemElement) {
      const schemaButtons = itemElement.querySelectorAll('.schema-btn');
      schemaButtons.forEach(button => {
        const buttonSchema = button.dataset.schema;
        button.classList.toggle('active', buttonSchema === schema);
      });
    }

    // Update MongoDB via API
    try {
      const response = await fetch(`${API_BASE_URL}/conversations/${id}/schema`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ schema })
      });

      if (!response.ok) {
        console.error('Error updating schema:', await response.text());
        // Revert to old schema if update failed
        item.schema = oldSchema;
        if (itemElement) {
          const schemaButtons = itemElement.querySelectorAll('.schema-btn');
          schemaButtons.forEach(button => {
            const buttonSchema = button.dataset.schema;
            button.classList.toggle('active', buttonSchema === oldSchema);
          });
        }
        alert('Failed to update schema on server. Please try again.');
        return;
      }

      // Apply filters to update UI if needed
      if (activeSchema) {
        applyFilters();
      }
    } catch (error) {
      console.error('Failed to update schema:', error);
      // Revert to old schema if update failed
      item.schema = oldSchema;
      if (itemElement) {
        const schemaButtons = itemElement.querySelectorAll('.schema-btn');
        schemaButtons.forEach(button => {
          const buttonSchema = button.dataset.schema;
          button.classList.toggle('active', buttonSchema === oldSchema);
        });
      }
      alert('Failed to update schema: ' + error.message);
    }
  }

  // Show QDrant confirmation dialog
  function showQdrantConfirmDialog(item) {
    // Create dialog
    const dialog = document.createElement('div');
    dialog.className = 'qdrant-confirm-dialog';
    dialog.innerHTML = `
    <div class="qdrant-confirm-content">
      <h3 class="qdrant-confirm-title">Add to QDrant</h3>
      <p class="qdrant-confirm-text">Would you like to add this question to QDrant?</p>
      <div class="qdrant-confirm-buttons">
        <button class="qdrant-confirm-btn cancel">Cancel</button>
        <button class="qdrant-confirm-btn confirm">Add to QDrant</button>
      </div>
    </div>
  `;

    // Add event listeners
    const cancelBtn = dialog.querySelector('.cancel');
    const confirmBtn = dialog.querySelector('.confirm');

    cancelBtn.addEventListener('click', () => {
      dialog.remove();
    });

    confirmBtn.addEventListener('click', () => {
      dialog.remove();
      fillQdrantForm(item);
    });

    document.body.appendChild(dialog);
  }

  // Fill QDrant form and scroll to top
  function fillQdrantForm(item) {
    // Get the form elements
    const questionTextarea = document.getElementById('qdrant-question');
    const cypherTextarea = document.getElementById('qdrant-cypher');

    // Fill with data
    questionTextarea.value = item.question || '';

    // Fill cypher query if available
    if (item.cypherQueries && item.cypherQueries.length > 0) {
      cypherTextarea.value = item.cypherQueries[0] || '';
    } else {
      cypherTextarea.value = '';
    }

    // Scroll to top smoothly
    window.scrollTo({ top: 0, behavior: 'smooth' });

    // Highlight the textareas
    questionTextarea.classList.add('highlighted');
    cypherTextarea.classList.add('highlighted');

    // Remove highlight after animation
    setTimeout(() => {
      questionTextarea.classList.remove('highlighted');
      cypherTextarea.classList.remove('highlighted');
    }, 2000);
  }

  // Event listener for the "Send to QDrant" button
  document.addEventListener('DOMContentLoaded', function() {
    const sendToQdrantBtn = document.getElementById('send-to-qdrant');

    if (sendToQdrantBtn) {
      sendToQdrantBtn.addEventListener('click', async function() {
        const questionTextarea = document.getElementById('qdrant-question');
        const cypherTextarea = document.getElementById('qdrant-cypher');

        // Validate input
        if (!questionTextarea.value.trim()) {
          alert('Please enter a question');
          return;
        }

        // Disable button while processing
        sendToQdrantBtn.disabled = true;
        sendToQdrantBtn.textContent = 'Sending...';

        try {
          // Prepare the data
          const data = {
            message: questionTextarea.value.trim(),
            cypher: cypherTextarea.value.trim(),
            schema: document.getElementById('qdrant-schema-filter')?.value || '',
            timestamp: Date.now()
          };

          // Send to backend
          const response = await fetch(`${API_BASE_URL}/qdrant/save`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
          });

          const result = await response.json();

          if (result.success) {
            alert('Successfully saved to QDrant!');

            // Clear the form
            questionTextarea.value = '';
            cypherTextarea.value = '';

            // Refresh QDrant data if in QDrant view mode
            if (isQdrantMode) {
              await fetchQdrantData();
              renderQdrantItems();
            }
          } else {
            throw new Error(result.error || 'Unknown error occurred');
          }
        } catch (error) {
          console.error('Error saving to QDrant:', error);
          alert(`Failed to save to QDrant: ${error.message}`);
        } finally {
          // Re-enable button
          sendToQdrantBtn.disabled = false;
          sendToQdrantBtn.textContent = 'Send to QDrant';
        }
      });
    }
  });
  // Event listeners for the icon-based schema selection
  document.addEventListener('DOMContentLoaded', function() {
    const mesaiOption = document.getElementById('mesai-option');
    const mukaveleOption = document.getElementById('mukavele-option');

    // Variable to track the current selected schema
    let selectedSchema = 'mesai'; // Default schema

    if (mesaiOption && mukaveleOption) {
      // Add click event listeners to schema options
      mesaiOption.addEventListener('click', function() {
        setSelectedSchema('mesai');
      });

      mukaveleOption.addEventListener('click', function() {
        setSelectedSchema('mukavele');
      });

      // Function to handle schema selection
      function setSelectedSchema(schema) {
        selectedSchema = schema;

        if (schema === 'mesai') {
          mesaiOption.classList.add('selected');
          mukaveleOption.classList.remove('selected');
        } else {
          mesaiOption.classList.remove('selected');
          mukaveleOption.classList.add('selected');
        }
      }
    }

    // Modify the Send to QDrant button event listener to use the selected schema
    const sendToQdrantBtn = document.getElementById('send-to-qdrant');

    if (sendToQdrantBtn) {
      // Store the original click handler to avoid duplicate listeners
      const originalClickHandler = sendToQdrantBtn.onclick;

      // Remove original click handler if it exists
      if (originalClickHandler) {
        sendToQdrantBtn.removeEventListener('click', originalClickHandler);
      }

      // Add new click handler
      sendToQdrantBtn.addEventListener('click', async function() {
        const questionTextarea = document.getElementById('qdrant-question');
        const cypherTextarea = document.getElementById('qdrant-cypher');

        // Validate input
        if (!questionTextarea.value.trim()) {
          alert('Please enter a question');
          return;
        }

        // Disable button while processing
        sendToQdrantBtn.disabled = true;
        sendToQdrantBtn.textContent = 'Sending...';

        try {
          // Prepare the data with the selected schema
          const data = {
            message: questionTextarea.value.trim(),
            cypher: cypherTextarea.value.trim(),
            schema: selectedSchema, // Use the selected schema value
            timestamp: Date.now()
          };

          console.log('Sending to QDrant with schema:', selectedSchema);

          // Send to backend
          const response = await fetch(`${API_BASE_URL}/qdrant/save`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
          });

          const result = await response.json();

          if (result.success) {
            alert('Successfully saved to QDrant!');

            // Clear the form
            questionTextarea.value = '';
            cypherTextarea.value = '';

            // Refresh QDrant data if in QDrant view mode
            if (window.isQdrantMode) {
              await window.fetchQdrantData();
              window.renderQdrantItems();
            }
          } else {
            throw new Error(result.error || 'Unknown error occurred');
          }
        } catch (error) {
          console.error('Error saving to QDrant:', error);
          alert(`Failed to save to QDrant: ${error.message}`);
        } finally {
          // Re-enable button
          sendToQdrantBtn.disabled = false;
          sendToQdrantBtn.textContent = 'Send to QDrant';
        }
      });
    }
  });
</script>

<!-- Include fix scripts -->
<script src="comprehensive-fix.js"></script>
<script src="comprehensive-fix-2.js"></script>
<script src="ui-debug-tool.js"></script>
<script src="continuous-loading-fix.js"></script>
<script src="feedback-system-fixes.js"></script>
<script src="feedback-system-fixes-2.js"></script>
<script src="similarity-fix.js"></script>
<script src="debug-mode.js"></script>
<script src="pagination-fix.js"></script>
<script src="complete-filter-fix.js"></script>
<script src="unix-timestamp-fix.js"></script>
<!--<script src="schema-filter-fix.js"></script>-->
<!--<script src="feedback-filter-fix.js"></script>-->
<!--Experimental-->
<!--<script src="force-data-points.js"></script>-->
</body>
</html>